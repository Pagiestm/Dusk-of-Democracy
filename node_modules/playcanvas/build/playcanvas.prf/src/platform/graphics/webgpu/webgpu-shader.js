import { StringIds } from '../../../core/string-ids.js';
import { SHADERLANGUAGE_WGSL } from '../constants.js';
import { ShaderProcessorGLSL } from '../shader-processor-glsl.js';
import { WebgpuShaderProcessorWGSL } from './webgpu-shader-processor-wgsl.js';

const computeShaderIds = new StringIds();
class WebgpuShader {
		destroy(shader) {
				this._vertexCode = null;
				this._fragmentCode = null;
		}
		createShaderModule(code, shaderType) {
				const device = this.shader.device;
				const wgpu = device.wgpu;
				const shaderModule = wgpu.createShaderModule({
						code: code
				});
				return shaderModule;
		}
		getVertexShaderModule() {
				return this.createShaderModule(this._vertexCode, 'Vertex');
		}
		getFragmentShaderModule() {
				return this.createShaderModule(this._fragmentCode, 'Fragment');
		}
		getComputeShaderModule() {
				return this.createShaderModule(this._computeCode, 'Compute');
		}
		processGLSL() {
				const shader = this.shader;
				const processed = ShaderProcessorGLSL.run(shader.device, shader.definition, shader);
				this._vertexCode = this.transpile(processed.vshader, 'vertex', shader.definition.vshader);
				this._fragmentCode = this.transpile(processed.fshader, 'fragment', shader.definition.fshader);
				if (!(this._vertexCode && this._fragmentCode)) {
						shader.failed = true;
				} else {
						shader.ready = true;
				}
				shader.meshUniformBufferFormat = processed.meshUniformBufferFormat;
				shader.meshBindGroupFormat = processed.meshBindGroupFormat;
				shader.attributes = processed.attributes;
		}
		processWGSL() {
				const shader = this.shader;
				const processed = WebgpuShaderProcessorWGSL.run(shader.device, shader.definition, shader);
				this._vertexCode = processed.vshader;
				this._fragmentCode = processed.fshader;
				shader.meshUniformBufferFormat = processed.meshUniformBufferFormat;
				shader.meshBindGroupFormat = processed.meshBindGroupFormat;
				shader.attributes = processed.attributes;
		}
		transpile(src, shaderType, originalSrc) {
				const device = this.shader.device;
				if (!device.glslang || !device.twgsl) {
						console.error(`Cannot transpile shader [${this.shader.label}] - shader transpilers (glslang/twgsl) are not available. Make sure to provide glslangUrl and twgslUrl when creating the device.`, {
								shader: this.shader
						});
						return null;
				}
				try {
						const spirv = device.glslang.compileGLSL(src, shaderType);
						const wgsl = device.twgsl.convertSpirV2WGSL(spirv);
						return wgsl;
				} catch (err) {
						console.error(`Failed to transpile webgl ${shaderType} shader [${this.shader.label}] to WebGPU while rendering ${ void 0}, error:\n [${err.stack}]`, {
								processed: src,
								original: originalSrc,
								shader: this.shader,
								error: err,
								stack: err.stack
						});
				}
		}
		get vertexCode() {
				return this._vertexCode;
		}
		get fragmentCode() {
				return this._fragmentCode;
		}
		get computeKey() {
				if (this._computeKey === undefined) {
						const keyString = `${this._computeCode}|${this.computeEntryPoint}`;
						this._computeKey = computeShaderIds.get(keyString);
				}
				return this._computeKey;
		}
		loseContext() {}
		restoreContext(device, shader) {}
		constructor(shader){
				this._vertexCode = null;
				this._fragmentCode = null;
				this._computeCode = null;
				this.vertexEntryPoint = 'main';
				this.fragmentEntryPoint = 'main';
				this.computeEntryPoint = 'main';
				this.shader = shader;
				const definition = shader.definition;
				if (definition.shaderLanguage === SHADERLANGUAGE_WGSL) {
						if (definition.cshader) {
								this._computeCode = definition.cshader ?? null;
								this.computeUniformBufferFormats = definition.computeUniformBufferFormats;
								this.computeBindGroupFormat = definition.computeBindGroupFormat;
								if (definition.computeEntryPoint) {
										this.computeEntryPoint = definition.computeEntryPoint;
								}
						} else {
								this.vertexEntryPoint = 'vertexMain';
								this.fragmentEntryPoint = 'fragmentMain';
								if (definition.processingOptions) {
										this.processWGSL();
								} else {
										this._vertexCode = definition.vshader ?? null;
										this._fragmentCode = definition.fshader ?? null;
										shader.meshUniformBufferFormat = definition.meshUniformBufferFormat;
										shader.meshBindGroupFormat = definition.meshBindGroupFormat;
								}
						}
						shader.ready = true;
				} else {
						if (definition.processingOptions) {
								this.processGLSL();
						}
				}
		}
}

export { WebgpuShader };
