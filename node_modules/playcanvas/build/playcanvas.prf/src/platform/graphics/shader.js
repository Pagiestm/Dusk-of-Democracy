import { platform } from '../../core/platform.js';
import { Preprocessor } from '../../core/preprocessor.js';
import { SHADERLANGUAGE_WGSL, SHADERLANGUAGE_GLSL } from './constants.js';
import { ShaderDefinitionUtils } from './shader-definition-utils.js';

let id = 0;
class Shader {
		init() {
				this.ready = false;
				this.failed = false;
		}
		get label() {
				return `Shader Id ${this.id} (${this.definition.shaderLanguage === SHADERLANGUAGE_WGSL ? 'WGSL' : 'GLSL'}) ${this.name}`;
		}
		destroy() {
				this.device.onDestroyShader(this);
				this.impl.destroy(this);
		}
		loseContext() {
				this.init();
				this.impl.loseContext();
		}
		restoreContext() {
				this.impl.restoreContext(this.device, this);
		}
		constructor(graphicsDevice, definition){
				this.attributes = new Map();
				this.id = id++;
				this.device = graphicsDevice;
				this.definition = definition;
				this.name = definition.name || 'Untitled';
				this.init();
				if (definition.cshader) {
						const definesCode = ShaderDefinitionUtils.getDefinesCode(graphicsDevice, definition.cdefines);
						const cshader = definesCode + definition.cshader;
						definition.cshader = Preprocessor.run(cshader, definition.cincludes, {
								sourceName: `compute shader for ${this.label}`,
								stripDefines: true
						});
				} else {
						const wgsl = definition.shaderLanguage === SHADERLANGUAGE_WGSL;
						definition.vshader = Preprocessor.run(definition.vshader, definition.vincludes, {
								sourceName: `vertex shader for ${this.label}`,
								stripDefines: wgsl
						});
						if (definition.shaderLanguage === SHADERLANGUAGE_GLSL) {
								var _definition;
								(_definition = definition).attributes ?? (_definition.attributes = ShaderDefinitionUtils.collectAttributes(definition.vshader));
						}
						const stripUnusedColorAttachments = graphicsDevice.isWebGL2 && (platform.name === 'osx' || platform.name === 'ios');
						definition.fshader = Preprocessor.run(definition.fshader, definition.fincludes, {
								stripUnusedColorAttachments,
								stripDefines: wgsl,
								sourceName: `fragment shader for ${this.label}`
						});
						if (!definition.vshader || !definition.fshader) {
								this.failed = true;
								return;
						}
				}
				this.impl = graphicsDevice.createShaderImpl(this);
		}
}

export { Shader };
