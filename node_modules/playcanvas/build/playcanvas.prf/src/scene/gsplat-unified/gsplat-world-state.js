class GSplatWorldState {
		estimateTextureSize(splats, maxSize) {
				const fits = (size)=>{
						let rows = 0;
						for (const splat of splats){
								rows += Math.ceil(splat.activeSplats / size);
								if (rows > size) return false;
						}
						return true;
				};
				let low = 1;
				let high = maxSize;
				let bestSize = null;
				while(low <= high){
						const mid = Math.floor((low + high) / 2);
						if (fits(mid)) {
								bestSize = mid;
								high = mid - 1;
						} else {
								low = mid + 1;
						}
				}
				if (bestSize === null) {
						this.textureSize = 0;
						return false;
				}
				this.textureSize = bestSize;
				return true;
		}
		destroy() {
				this.splats.forEach((splat)=>splat.destroy());
				this.splats.length = 0;
		}
		assignLines(splats, size) {
				if (splats.length === 0) {
						this.totalUsedPixels = 0;
						return;
				}
				let start = 0;
				for (const splat of splats){
						const activeSplats = splat.activeSplats;
						const numLines = Math.ceil(activeSplats / size);
						splat.setLines(start, numLines, size, activeSplats);
						start += numLines;
				}
				this.totalUsedPixels = start * size;
		}
		constructor(device, version, splats){
				this.version = 0;
				this.sortParametersSet = false;
				this.sortedBefore = false;
				this.splats = [];
				this.textureSize = 0;
				this.totalUsedPixels = 0;
				this.pendingReleases = [];
				this.version = version;
				this.splats = splats;
				this.estimateTextureSize(this.splats, device.maxTextureSize);
				this.assignLines(this.splats, this.textureSize);
		}
}

export { GSplatWorldState };
