import { Mat4 } from '../../core/math/mat4.js';
import { Vec3 } from '../../core/math/vec3.js';
import { Quat } from '../../core/math/quat.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { BlendState } from '../../platform/graphics/blend-state.js';
import { DepthState } from '../../platform/graphics/depth-state.js';
import { CULLFACE_NONE } from '../../platform/graphics/constants.js';

const _viewMat = new Mat4();
const _modelScale = new Vec3();
const _modelRotation = new Quat();
const _whiteColor = [
		1,
		1,
		1
];
class GSplatWorkBufferRenderPass extends RenderPass {
		init(renderTarget) {
				super.init(renderTarget);
				this.colorOps.clear = false;
				this.depthStencilOps.clearDepth = false;
		}
		update(splats, cameraNode, colorsByLod) {
				this.splats.length = 0;
				this.colorsByLod = colorsByLod;
				for(let i = 0; i < splats.length; i++){
						const splatInfo = splats[i];
						if (splatInfo.activeSplats > 0) {
								this.splats.push(splatInfo);
						}
				}
				this.cameraNode = cameraNode;
				return this.splats.length > 0;
		}
		execute() {
				const { device, splats, cameraNode } = this;
				device.setBlendState(BlendState.NOBLEND);
				device.setCullMode(CULLFACE_NONE);
				device.setDepthState(DepthState.NODEPTH);
				device.setStencilState();
				const viewInvMat = cameraNode.getWorldTransform();
				const viewMat = _viewMat.copy(viewInvMat).invert();
				device.scope.resolve('matrix_view').setValue(viewMat.data);
				for(let i = 0; i < splats.length; i++){
						this.renderSplat(splats[i]);
				}
		}
		renderSplat(splatInfo) {
				const { device, resource } = splatInfo;
				const scope = device.scope;
				const { activeSplats, lineStart, viewport, intervalTexture } = splatInfo;
				const workBufferModifier = splatInfo.getWorkBufferModifier?.() ?? null;
				const formatHash = resource.format.hash;
				const formatDeclarations = resource.format.getInputDeclarations();
				const workBufferRenderInfo = resource.getWorkBufferRenderInfo(intervalTexture !== null, this.colorOnly, workBufferModifier, formatHash, formatDeclarations, this.workBuffer.format);
				workBufferRenderInfo.material.setParameters(device);
				if (intervalTexture) {
						scope.resolve('uIntervalsTexture').setValue(intervalTexture.texture);
				}
				scope.resolve('uActiveSplats').setValue(activeSplats);
				scope.resolve('uStartLine').setValue(lineStart);
				scope.resolve('uViewportWidth').setValue(viewport.z);
				const color = this.colorsByLod?.[splatInfo.lodIndex] ?? this.colorsByLod?.[0] ?? _whiteColor;
				scope.resolve('uColorMultiply').setValue(color);
				const worldTransform = splatInfo.node.getWorldTransform();
				worldTransform.getScale(_modelScale);
				_modelRotation.setFromMat4(worldTransform);
				if (_modelRotation.w < 0) {
						_modelRotation.mulScalar(-1);
				}
				this._modelScaleData[0] = _modelScale.x;
				this._modelScaleData[1] = _modelScale.y;
				this._modelScaleData[2] = _modelScale.z;
				this._modelRotationData[0] = _modelRotation.x;
				this._modelRotationData[1] = _modelRotation.y;
				this._modelRotationData[2] = _modelRotation.z;
				this._modelRotationData[3] = _modelRotation.w;
				scope.resolve('matrix_model').setValue(worldTransform.data);
				scope.resolve('model_scale').setValue(this._modelScaleData);
				scope.resolve('model_rotation').setValue(this._modelRotationData);
				scope.resolve('uId').setValue(splatInfo.placementId);
				if (splatInfo.parameters) {
						for (const param of splatInfo.parameters.values()){
								param.scopeId.setValue(param.data);
						}
				}
				const instanceStreams = splatInfo.getInstanceStreams?.();
				if (instanceStreams) {
						instanceStreams.syncWithFormat(splatInfo.resource.format);
						for (const [name, texture] of instanceStreams.textures){
								scope.resolve(name).setValue(texture);
						}
				}
				workBufferRenderInfo.quadRender.render(viewport);
		}
		destroy() {
				this.splats.length = 0;
				super.destroy();
		}
		constructor(device, workBuffer, colorOnly = false){
				super(device), this.splats = [], this.colorsByLod = undefined, this.cameraNode = null, this._modelScaleData = new Float32Array(3), this._modelRotationData = new Float32Array(4);
				this.workBuffer = workBuffer;
				this.colorOnly = colorOnly;
		}
}

export { GSplatWorkBufferRenderPass };
