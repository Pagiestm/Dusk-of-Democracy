var wgslGsplatCopyToWorkBufferPS = `
#define GSPLAT_CENTER_NOPROJ
#include "gsplatHelpersVS"
#include "gsplatFormatVS"
#include "gsplatStructsVS"
#include "gsplatDeclarationsVS"
#include "gsplatCenterVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatReadVS"
var<private> processOutput: FragmentOutput;
#include "gsplatWorkBufferOutputVS"
#include "gsplatModifyVS"
uniform uStartLine: i32;
uniform uViewportWidth: i32;
#ifdef GSPLAT_LOD
	var uIntervalsTexture: texture_2d<u32>;
#endif
uniform uColorMultiply: vec3f;
uniform uActiveSplats: i32;
uniform model_scale: vec3f;
uniform model_rotation: vec4f;
#ifdef GSPLAT_ID
	uniform uId: u32;
#endif
@fragment
fn fragmentMain(input: FragmentInput) -> FragmentOutput {
	let localFragCoords = vec2i(i32(input.position.x), i32(input.position.y) - uniform.uStartLine);
	let targetIndex = localFragCoords.y * uniform.uViewportWidth + localFragCoords.x;
	
	if (targetIndex >= uniform.uActiveSplats) {
		writeDataColor(vec4f(0.0));
		#ifndef GSPLAT_COLOR_ONLY
			writeDataTransformA(vec4u(0u));
			writeDataTransformB(vec4u(0u));
		#endif
	} else {
		#ifdef GSPLAT_LOD
			let intervalsSize = i32(textureDimensions(uIntervalsTexture, 0).x);
			let intervalUV = vec2i(targetIndex % intervalsSize, targetIndex / intervalsSize);
			let originalIndex = textureLoad(uIntervalsTexture, intervalUV, 0).r;
		#else
			let originalIndex = targetIndex;
		#endif
		
		setSplat(u32(originalIndex));
		var modelCenter = getCenter();
		var worldCenter = (uniform.matrix_model * vec4f(modelCenter, 1.0)).xyz;
		var center: SplatCenter;
		initCenter(modelCenter, &center);
		let srcRotation = getRotation().yzwx;
		let srcScale = getScale();
		var worldRotation = quatMul(uniform.model_rotation, srcRotation);
		if (worldRotation.w < 0.0) {
			worldRotation = -worldRotation;
		}
		var worldScale = uniform.model_scale * srcScale;
		let originalCenter = worldCenter;
		modifySplatCenter(&worldCenter);
		modifySplatRotationScale(originalCenter, worldCenter, &worldRotation, &worldScale);
		var color = getColor();
		#if SH_BANDS > 0
			let dir = normalize(center.view * mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));
			var sh: array<vec3f, SH_COEFFS>;
			var scale: f32;
			readSHData(&sh, &scale);
			color = vec4f(color.xyz + evalSH(&sh, dir) * scale, color.w);
		#endif
		modifySplatColor(worldCenter, &color);
		color = vec4f(color.xyz * uniform.uColorMultiply, color.w);
		writeDataColor(color);
		#ifndef GSPLAT_COLOR_ONLY
			writeDataTransformA(vec4u(bitcast<u32>(worldCenter.x), bitcast<u32>(worldCenter.y), bitcast<u32>(worldCenter.z), pack2x16float(worldRotation.xy)));
			writeDataTransformB(vec4u(pack2x16float(vec2f(worldRotation.z, worldScale.x)), pack2x16float(worldScale.yz), 0u, 0u));
		#endif
		#ifdef GSPLAT_ID
			writePcId(vec4u(uniform.uId, 0u, 0u, 0u));
		#endif
	}
	
	return processOutput;
}
`;

export { wgslGsplatCopyToWorkBufferPS as default };
