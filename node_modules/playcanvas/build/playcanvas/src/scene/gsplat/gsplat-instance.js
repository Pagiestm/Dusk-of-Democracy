import { Mat4 } from '../../core/math/mat4.js';
import { Vec3 } from '../../core/math/vec3.js';
import { CULLFACE_NONE, PIXELFORMAT_R32U, SEMANTIC_ATTR13, SEMANTIC_POSITION } from '../../platform/graphics/constants.js';
import { MeshInstance } from '../mesh-instance.js';
import { GSplatResolveSH } from './gsplat-resolve-sh.js';
import { GSplatSorter } from './gsplat-sorter.js';
import { GSplatSogData } from './gsplat-sog-data.js';
import { GSplatResourceBase } from './gsplat-resource-base.js';
import { ShaderMaterial } from '../materials/shader-material.js';
import { BLEND_NONE, BLEND_PREMULTIPLIED } from '../constants.js';

const mat = new Mat4();
const cameraPosition = new Vec3();
const cameraDirection = new Vec3();
class GSplatInstance {
		destroy() {
				this.resource?.releaseMesh();
				this.orderTexture?.destroy();
				this.resolveSH?.destroy();
				this.material?.destroy();
				this.meshInstance?.destroy();
				this.sorter?.destroy();
		}
		setMaterialOrderTexture(material) {
				material.setParameter('splatOrder', this.orderTexture);
				material.setParameter('splatTextureSize', this.orderTexture.width);
		}
		set material(value) {
				if (this._material !== value) {
						this._material = value;
						this.setMaterialOrderTexture(this._material);
						if (this.meshInstance) {
								this.meshInstance.material = value;
						}
				}
		}
		get material() {
				return this._material;
		}
		configureMaterial(material, options = {}) {
				this.resource.configureMaterial(material, null, this.resource.format.getInputDeclarations());
				material.setParameter('numSplats', 0);
				this.setMaterialOrderTexture(material);
				material.setParameter('alphaClip', 0.3);
				material.setDefine(`DITHER_${options.dither ? 'BLUENOISE' : 'NONE'}`, '');
				material.cull = CULLFACE_NONE;
				material.blendType = options.dither ? BLEND_NONE : BLEND_PREMULTIPLIED;
				material.depthWrite = !!options.dither;
		}
		sort(cameraNode) {
				if (this.sorter) {
						const cameraMat = cameraNode.getWorldTransform();
						cameraMat.getTranslation(cameraPosition);
						cameraMat.getZ(cameraDirection);
						const modelMat = this.meshInstance.node.getWorldTransform();
						const invModelMat = mat.invert(modelMat);
						invModelMat.transformPoint(cameraPosition, cameraPosition);
						invModelMat.transformVector(cameraDirection, cameraDirection);
						if (!cameraPosition.equalsApprox(this.lastCameraPosition) || !cameraDirection.equalsApprox(this.lastCameraDirection)) {
								this.lastCameraPosition.copy(cameraPosition);
								this.lastCameraDirection.copy(cameraDirection);
								this.sorter.setCamera(cameraPosition, cameraDirection);
						}
				}
		}
		update() {
				if (this.cameras.length > 0) {
						const camera = this.cameras[0];
						this.sort(camera._node);
						this.resolveSH?.render(camera._node, this.meshInstance.node.getWorldTransform());
						this.cameras.length = 0;
				}
		}
		setHighQualitySH(value) {
				const { resource } = this;
				const { gsplatData } = resource;
				if (gsplatData instanceof GSplatSogData && gsplatData.shBands > 0 && value === !!this.resolveSH) {
						if (this.resolveSH) {
								this.resolveSH.destroy();
								this.resolveSH = null;
						} else {
								this.resolveSH = new GSplatResolveSH(resource.device, this);
						}
				}
		}
		constructor(resource, options = {}){
				this.options = {};
				this.sorter = null;
				this.lastCameraPosition = new Vec3();
				this.lastCameraDirection = new Vec3();
				this.resolveSH = null;
				this.cameras = [];
				this.resource = resource;
				const dims = resource.streams.textureDimensions;
				this.orderTexture = resource.streams.createTexture('splatOrder', PIXELFORMAT_R32U, dims);
				if (options.material) {
						this._material = options.material;
						this.setMaterialOrderTexture(this._material);
				} else {
						this._material = new ShaderMaterial({
								uniqueName: 'SplatMaterial',
								vertexGLSL: '#include "gsplatVS"',
								fragmentGLSL: '#include "gsplatPS"',
								vertexWGSL: '#include "gsplatVS"',
								fragmentWGSL: '#include "gsplatPS"',
								attributes: {
										vertex_position: SEMANTIC_POSITION,
										vertex_id_attrib: SEMANTIC_ATTR13
								}
						});
						this.configureMaterial(this._material);
						this._material.update();
				}
				resource.ensureMesh();
				this.meshInstance = new MeshInstance(resource.mesh, this._material);
				this.meshInstance.setInstancing(resource.instanceIndices, true);
				this.meshInstance.gsplatInstance = this;
				this.meshInstance.instancingCount = 0;
				const centers = resource.centers.slice();
				const chunks = resource.chunks?.slice();
				this.sorter = new GSplatSorter(options.scene);
				this.sorter.init(this.orderTexture, centers, chunks);
				this.sorter.on('updated', (count)=>{
						this.meshInstance.instancingCount = Math.ceil(count / GSplatResourceBase.instanceSize);
						this.material.setParameter('numSplats', count);
				});
				this.setHighQualitySH(options.highQualitySH ?? false);
		}
}

export { GSplatInstance };
