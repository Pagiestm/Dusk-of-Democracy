import { Vec2 } from '../../core/math/vec2.js';
import { ADDRESS_CLAMP_TO_EDGE, FILTER_NEAREST } from '../../platform/graphics/constants.js';
import { Texture } from '../../platform/graphics/texture.js';

class GSplatStreams {
		get textureDimensions() {
				return this._textureDimensions;
		}
		destroy() {
				for (const texture of this.textures.values()){
						texture.destroy();
				}
				this.textures.clear();
		}
		init(format, numElements) {
				this.format = format;
				this._textureDimensions = this.evalTextureSize(numElements);
				const streams = this._isInstance ? format.instanceStreams : format.resourceStreams;
				for (const stream of streams){
						const texture = this.createTexture(stream.name, stream.format, this._textureDimensions);
						this.textures.set(stream.name, texture);
				}
				this._formatVersion = format.extraStreamsVersion;
		}
		getTexture(name) {
				this.syncWithFormat(this.format);
				return this.textures.get(name);
		}
		getTexturesInOrder() {
				const result = [];
				if (this.format) {
						const allStreams = this._isInstance ? this.format.instanceStreams : this.format.resourceStreams;
						for (const stream of allStreams){
								const texture = this.textures.get(stream.name);
								if (texture) {
										result.push(texture);
								}
						}
				}
				return result;
		}
		syncWithFormat(format) {
				if (format) {
						if (this.format === format && this._formatVersion === format.extraStreamsVersion) {
								return;
						}
						this.format = format;
						const streams = this._isInstance ? format.instanceStreams : format.resourceStreams;
						for (const stream of streams){
								if (!this.textures.has(stream.name)) {
										const texture = this.createTexture(stream.name, stream.format, this._textureDimensions);
										this.textures.set(stream.name, texture);
								}
						}
						this._formatVersion = format.extraStreamsVersion;
				}
		}
		evalTextureSize(count) {
				const width = Math.ceil(Math.sqrt(count));
				return new Vec2(width, Math.ceil(count / width));
		}
		resize(width, height) {
				this._textureDimensions.set(width, height);
				for (const texture of this.textures.values()){
						texture.resize(width, height);
				}
		}
		createTexture(name, format, size, data) {
				const options = {
						name: name,
						width: size.x,
						height: size.y,
						format: format,
						cubemap: false,
						mipmaps: false,
						minFilter: FILTER_NEAREST,
						magFilter: FILTER_NEAREST,
						addressU: ADDRESS_CLAMP_TO_EDGE,
						addressV: ADDRESS_CLAMP_TO_EDGE
				};
				if (data) {
						options.levels = [
								data
						];
				}
				return new Texture(this.device, options);
		}
		constructor(device, isInstance = false){
				this.format = null;
				this.textures = new Map();
				this._textureDimensions = new Vec2();
				this._isInstance = false;
				this._formatVersion = -1;
				this.device = device;
				this._isInstance = isInstance;
		}
}

export { GSplatStreams };
