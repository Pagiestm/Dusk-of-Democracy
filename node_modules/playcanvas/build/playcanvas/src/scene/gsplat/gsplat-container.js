import { math } from '../../core/math/math.js';
import { BoundingBox } from '../../core/shape/bounding-box.js';
import { GSplatResourceBase } from './gsplat-resource-base.js';

class GSplatContainer extends GSplatResourceBase {
		get maxSplats() {
				return this._maxSplats;
		}
		get numSplats() {
				return this._numSplats;
		}
		update(numSplats = this._numSplats, centersUpdated = true) {
				this._numSplats = math.clamp(numSplats, 0, this._maxSplats);
				if (centersUpdated) {
						this.centersVersion++;
				}
		}
		configureMaterialDefines(defines) {
				defines.set('SH_BANDS', '0');
		}
		configureMaterial(material, workBufferModifier = null, formatDeclarations) {
				super.configureMaterial(material, workBufferModifier, formatDeclarations);
				const chunks = this.device.isWebGPU ? material.shaderChunks.wgsl : material.shaderChunks.glsl;
				chunks.set('gsplatContainerDeclarationsVS', this.format.getInputDeclarations());
				chunks.set('gsplatDeclarationsVS', '#include "gsplatContainerDeclVS"');
				chunks.set('gsplatReadVS', this.format.getReadCode());
		}
		constructor(device, maxSplats, format){
				const centers = new Float32Array(maxSplats * 3);
				const aabb = new BoundingBox();
				const gsplatData = {
						numSplats: maxSplats,
						getCenters: ()=>centers,
						calcAabb: (box)=>box.copy(aabb)
				};
				super(device, gsplatData), this._maxSplats = 0, this._numSplats = 0;
				this._format = format;
				this._maxSplats = maxSplats;
				this._numSplats = maxSplats;
				this.streams.init(this._format, maxSplats);
		}
}

export { GSplatContainer };
