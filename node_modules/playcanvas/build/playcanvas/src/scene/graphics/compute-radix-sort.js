import { Compute } from '../../platform/graphics/compute.js';
import { Shader } from '../../platform/graphics/shader.js';
import { StorageBuffer } from '../../platform/graphics/storage-buffer.js';
import { BindGroupFormat, BindStorageBufferFormat, BindUniformBufferFormat } from '../../platform/graphics/bind-group-format.js';
import { UniformBufferFormat, UniformFormat } from '../../platform/graphics/uniform-buffer-format.js';
import { UNIFORMTYPE_UINT, SHADERSTAGE_COMPUTE, BUFFERUSAGE_COPY_SRC, BUFFERUSAGE_COPY_DST, SHADERLANGUAGE_WGSL } from '../../platform/graphics/constants.js';
import { PrefixSumKernel } from './prefix-sum-kernel.js';
import { radixSort4bitSource } from '../shader-lib/wgsl/chunks/radix-sort/compute-radix-sort-4bit.js';
import { radixSortReorderSource } from '../shader-lib/wgsl/chunks/radix-sort/compute-radix-sort-reorder.js';

const BITS_PER_PASS = 4;
const BUCKET_COUNT = 16;
const WORKGROUP_SIZE_X = 16;
const WORKGROUP_SIZE_Y = 16;
const THREADS_PER_WORKGROUP = WORKGROUP_SIZE_X * WORKGROUP_SIZE_Y;
class ComputeRadixSort {
		destroy() {
				this._destroyBuffers();
				this._destroyPasses();
				this._blockSumBindGroupFormat?.destroy();
				this._reorderBindGroupFormat?.destroy();
				this._blockSumBindGroupFormat = null;
				this._reorderBindGroupFormat = null;
				this._uniformBufferFormat = null;
		}
		_destroyPasses() {
				for (const pass of this._passes){
						pass.blockSumCompute.shader?.destroy();
						pass.reorderCompute.shader?.destroy();
				}
				this._passes.length = 0;
				this._numBits = 0;
		}
		_destroyBuffers() {
				this._keys0?.destroy();
				this._keys1?.destroy();
				this._values0?.destroy();
				this._values1?.destroy();
				this._localPrefixSums?.destroy();
				this._blockSums?.destroy();
				this._sortedIndices?.destroy();
				this._prefixSumKernel?.destroy();
				this._keys0 = null;
				this._keys1 = null;
				this._values0 = null;
				this._values1 = null;
				this._localPrefixSums = null;
				this._blockSums = null;
				this._sortedIndices = null;
				this._prefixSumKernel = null;
				this._workgroupCount = 0;
				this._allocatedWorkgroupCount = 0;
		}
		get sortedIndices() {
				return this._sortedIndices;
		}
		_createBindGroupFormats() {
				const device = this.device;
				this._uniformBufferFormat = new UniformBufferFormat(device, [
						new UniformFormat('workgroupCount', UNIFORMTYPE_UINT),
						new UniformFormat('elementCount', UNIFORMTYPE_UINT)
				]);
				this._blockSumBindGroupFormat = new BindGroupFormat(device, [
						new BindStorageBufferFormat('input', SHADERSTAGE_COMPUTE, true),
						new BindStorageBufferFormat('local_prefix_sums', SHADERSTAGE_COMPUTE, false),
						new BindStorageBufferFormat('block_sums', SHADERSTAGE_COMPUTE, false),
						new BindUniformBufferFormat('uniforms', SHADERSTAGE_COMPUTE)
				]);
				this._reorderBindGroupFormat = new BindGroupFormat(device, [
						new BindStorageBufferFormat('inputKeys', SHADERSTAGE_COMPUTE, true),
						new BindStorageBufferFormat('outputKeys', SHADERSTAGE_COMPUTE, false),
						new BindStorageBufferFormat('local_prefix_sum', SHADERSTAGE_COMPUTE, true),
						new BindStorageBufferFormat('prefix_block_sum', SHADERSTAGE_COMPUTE, true),
						new BindStorageBufferFormat('inputValues', SHADERSTAGE_COMPUTE, true),
						new BindStorageBufferFormat('outputValues', SHADERSTAGE_COMPUTE, false),
						new BindUniformBufferFormat('uniforms', SHADERSTAGE_COMPUTE)
				]);
		}
		_createPasses(numBits) {
				this._destroyPasses();
				this._numBits = numBits;
				const numPasses = numBits / BITS_PER_PASS;
				for(let pass = 0; pass < numPasses; pass++){
						const bitOffset = pass * BITS_PER_PASS;
						const isFirstPass = pass === 0;
						const blockSumShader = this._createShader(`RadixSort4bit-BlockSum-${bitOffset}`, radixSort4bitSource, 'radix_sort', bitOffset, false, this._blockSumBindGroupFormat);
						const reorderShader = this._createShader(`RadixSort4bit-Reorder-${bitOffset}`, radixSortReorderSource, 'radix_sort_reorder', bitOffset, isFirstPass, this._reorderBindGroupFormat);
						const blockSumCompute = new Compute(this.device, blockSumShader, `RadixSort4bit-BlockSum-${bitOffset}`);
						const reorderCompute = new Compute(this.device, reorderShader, `RadixSort4bit-Reorder-${bitOffset}`);
						this._passes.push({
								blockSumCompute,
								reorderCompute
						});
				}
		}
		_allocateBuffers(elementCount, numBits) {
				const workgroupCount = Math.ceil(elementCount / THREADS_PER_WORKGROUP);
				const buffersNeedRealloc = workgroupCount > this._allocatedWorkgroupCount || !this._keys0;
				const passesNeedRecreate = numBits !== this._numBits;
				this._workgroupCount = workgroupCount;
				this._dispatchSize = this._findOptimalDispatchSize(workgroupCount);
				if (buffersNeedRealloc) {
						this._destroyBuffers();
						this._allocatedWorkgroupCount = workgroupCount;
						this._workgroupCount = workgroupCount;
						this._dispatchSize = this._findOptimalDispatchSize(workgroupCount);
						const elementSize = elementCount * 4;
						const blockSumSize = BUCKET_COUNT * workgroupCount * 4;
						this._keys0 = new StorageBuffer(this.device, elementSize, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
						this._keys1 = new StorageBuffer(this.device, elementSize, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
						this._values0 = new StorageBuffer(this.device, elementSize, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
						this._values1 = new StorageBuffer(this.device, elementSize, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
						this._localPrefixSums = new StorageBuffer(this.device, elementSize, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
						this._blockSums = new StorageBuffer(this.device, blockSumSize, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
						this._sortedIndices = new StorageBuffer(this.device, elementSize, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
						this._prefixSumKernel = new PrefixSumKernel(this.device);
				}
				this._prefixSumKernel.resize(this._blockSums, BUCKET_COUNT * workgroupCount);
				if (passesNeedRecreate) {
						this._createPasses(numBits);
				}
		}
		_findOptimalDispatchSize(workgroupCount) {
				const maxDimension = this.device.limits.maxComputeWorkgroupsPerDimension || 65535;
				if (workgroupCount <= maxDimension) {
						return {
								x: workgroupCount,
								y: 1
						};
				}
				const x = Math.floor(Math.sqrt(workgroupCount));
				const y = Math.ceil(workgroupCount / x);
				return {
						x,
						y
				};
		}
		_createShader(name, source, entryPoint, currentBit, isFirstPass, bindGroupFormat) {
				const cdefines = new Map();
				cdefines.set('{WORKGROUP_SIZE_X}', WORKGROUP_SIZE_X);
				cdefines.set('{WORKGROUP_SIZE_Y}', WORKGROUP_SIZE_Y);
				cdefines.set('{THREADS_PER_WORKGROUP}', THREADS_PER_WORKGROUP);
				cdefines.set('{CURRENT_BIT}', currentBit);
				cdefines.set('{IS_FIRST_PASS}', isFirstPass ? 1 : 0);
				return new Shader(this.device, {
						name: name,
						shaderLanguage: SHADERLANGUAGE_WGSL,
						cshader: source,
						cdefines: cdefines,
						computeEntryPoint: entryPoint,
						computeBindGroupFormat: bindGroupFormat,
						computeUniformBufferFormats: {
								uniforms: this._uniformBufferFormat
						}
				});
		}
		sort(keysBuffer, elementCount, numBits = 16) {
				this._elementCount = elementCount;
				this._allocateBuffers(elementCount, numBits);
				const device = this.device;
				const numPasses = numBits / BITS_PER_PASS;
				let currentKeys = keysBuffer;
				let currentValues = this._values0;
				let nextKeys = this._keys0;
				let nextValues = this._values1;
				for(let pass = 0; pass < numPasses; pass++){
						const { blockSumCompute, reorderCompute } = this._passes[pass];
						const isLastPass = pass === numPasses - 1;
						blockSumCompute.setParameter('input', currentKeys);
						blockSumCompute.setParameter('local_prefix_sums', this._localPrefixSums);
						blockSumCompute.setParameter('block_sums', this._blockSums);
						blockSumCompute.setParameter('workgroupCount', this._workgroupCount);
						blockSumCompute.setParameter('elementCount', elementCount);
						blockSumCompute.setupDispatch(this._dispatchSize.x, this._dispatchSize.y, 1);
						device.computeDispatch([
								blockSumCompute
						], 'RadixSort-BlockSum');
						this._prefixSumKernel.dispatch(device);
						const outputValues = isLastPass ? this._sortedIndices : nextValues;
						reorderCompute.setParameter('inputKeys', currentKeys);
						reorderCompute.setParameter('outputKeys', nextKeys);
						reorderCompute.setParameter('local_prefix_sum', this._localPrefixSums);
						reorderCompute.setParameter('prefix_block_sum', this._blockSums);
						reorderCompute.setParameter('inputValues', currentValues);
						reorderCompute.setParameter('outputValues', outputValues);
						reorderCompute.setParameter('workgroupCount', this._workgroupCount);
						reorderCompute.setParameter('elementCount', elementCount);
						reorderCompute.setupDispatch(this._dispatchSize.x, this._dispatchSize.y, 1);
						device.computeDispatch([
								reorderCompute
						], 'RadixSort-Reorder');
						if (!isLastPass) {
								currentKeys = nextKeys;
								nextKeys = currentKeys === this._keys0 ? this._keys1 : this._keys0;
								const tempValues = currentValues;
								currentValues = nextValues;
								nextValues = tempValues;
						}
				}
				return this._sortedIndices;
		}
		constructor(device){
				this._elementCount = 0;
				this._workgroupCount = 0;
				this._allocatedWorkgroupCount = 0;
				this._numBits = 0;
				this._keys0 = null;
				this._keys1 = null;
				this._values0 = null;
				this._values1 = null;
				this._localPrefixSums = null;
				this._blockSums = null;
				this._sortedIndices = null;
				this._prefixSumKernel = null;
				this._dispatchSize = {
						x: 1,
						y: 1
				};
				this._blockSumBindGroupFormat = null;
				this._reorderBindGroupFormat = null;
				this._uniformBufferFormat = null;
				this._passes = [];
				this.device = device;
				this._createBindGroupFormats();
		}
}

export { ComputeRadixSort };
