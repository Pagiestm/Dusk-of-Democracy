import { PIXELFORMAT_RGBA16U, CULLFACE_NONE, SEMANTIC_ATTR13, SEMANTIC_POSITION } from '../../platform/graphics/constants.js';
import { GSPLAT_FORWARD, GSPLAT_SHADOW, BLEND_PREMULTIPLIED, BLEND_ADDITIVE, SHADOWCAMERA_NAME } from '../constants.js';
import { ShaderMaterial } from '../materials/shader-material.js';
import { GSplatResourceBase } from '../gsplat/gsplat-resource-base.js';
import { MeshInstance } from '../mesh-instance.js';
import { math } from '../../core/math/math.js';

class GSplatRenderer {
		setRenderMode(renderMode) {
				const oldRenderMode = this.renderMode ?? 0;
				const wasForward = (oldRenderMode & GSPLAT_FORWARD) !== 0;
				const wasShadow = (oldRenderMode & GSPLAT_SHADOW) !== 0;
				const isForward = (renderMode & GSPLAT_FORWARD) !== 0;
				const isShadow = (renderMode & GSPLAT_SHADOW) !== 0;
				this.meshInstance.castShadow = isShadow;
				if (wasForward && !isForward) {
						this.layer.removeMeshInstances([
								this.meshInstance
						], true);
				}
				if (wasShadow && !isShadow) {
						this.layer.removeShadowCasters([
								this.meshInstance
						]);
				}
				if (!wasForward && isForward) {
						this.layer.addMeshInstances([
								this.meshInstance
						], true);
				}
				if (!wasShadow && isShadow) {
						this.layer.addShadowCasters([
								this.meshInstance
						]);
				}
				this.renderMode = renderMode;
		}
		destroy() {
				if (this.renderMode) {
						if (this.renderMode & GSPLAT_FORWARD) {
								this.layer.removeMeshInstances([
										this.meshInstance
								], true);
						}
						if (this.renderMode & GSPLAT_SHADOW) {
								this.layer.removeShadowCasters([
										this.meshInstance
								]);
						}
				}
				this._material.destroy();
				this.meshInstance.destroy();
		}
		get material() {
				return this._material;
		}
		configureMaterial() {
				const { device, workBuffer } = this;
				this._injectFormatChunks();
				this._material.setDefine('STORAGE_ORDER', device.isWebGPU);
				this._material.setDefine('SH_BANDS', '0');
				const colorStream = workBuffer.format.getStream('dataColor');
				if (colorStream && colorStream.format !== PIXELFORMAT_RGBA16U) {
						this._material.setDefine('GSPLAT_COLOR_FLOAT', '');
				}
				this._updateIdDefines();
				this._bindWorkBufferTextures();
				this._material.setParameter('numSplats', 0);
				if (workBuffer.orderTexture) {
						this._material.setParameter('splatOrder', workBuffer.orderTexture);
				}
				this._material.setParameter('alphaClip', 0.3);
				this._material.setDefine(`DITHER_${'NONE'}`, '');
				this._material.cull = CULLFACE_NONE;
				this._material.blendType = BLEND_PREMULTIPLIED;
				this._material.depthWrite = false;
				this._material.update();
		}
		_bindWorkBufferTextures() {
				const { workBuffer } = this;
				for (const stream of workBuffer.format.resourceStreams){
						const texture = workBuffer.getTexture(stream.name);
						if (texture) {
								this._material.setParameter(stream.name, texture);
						}
				}
		}
		_injectFormatChunks() {
				const chunks = this.device.isWebGPU ? this._material.shaderChunks.wgsl : this._material.shaderChunks.glsl;
				const wbFormat = this.workBuffer.format;
				chunks.set('gsplatDeclarationsVS', wbFormat.getInputDeclarations());
				chunks.set('gsplatReadVS', wbFormat.getReadCode());
		}
		update(count, textureSize) {
				this.meshInstance.instancingCount = Math.ceil(count / GSplatResourceBase.instanceSize);
				this._material.setParameter('numSplats', count);
				this._material.setParameter('splatTextureSize', textureSize);
				this.meshInstance.visible = count > 0;
		}
		setOrderData() {
				if (this.device.isWebGPU) {
						this._material.setParameter('splatOrder', this.workBuffer.orderBuffer);
				} else {
						this._material.setParameter('splatOrder', this.workBuffer.orderTexture);
				}
		}
		setOrderBuffer(buffer) {
				this._material.setParameter('splatOrder', buffer);
		}
		frameUpdate(params) {
				if (params.colorRamp) {
						this._material.setParameter('colorRampIntensity', params.colorRampIntensity);
				}
				this._syncWithWorkBufferFormat();
				if (this.forceCopyMaterial || params.material.dirty) {
						this.copyMaterialSettings(params.material);
						this.forceCopyMaterial = false;
				}
		}
		_updateIdDefines() {
				const hasPcId = !!this.workBuffer.format.getStream('pcId');
				this._material.setDefine('GSPLAT_UNIFIED_ID', hasPcId);
				this._material.setDefine('PICK_CUSTOM_ID', hasPcId);
		}
		_syncWithWorkBufferFormat() {
				const wbFormat = this.workBuffer.format;
				if (this._workBufferFormatVersion !== wbFormat.extraStreamsVersion) {
						this._workBufferFormatVersion = wbFormat.extraStreamsVersion;
						this.workBuffer.syncWithFormat();
						this._injectFormatChunks();
						this._bindWorkBufferTextures();
						this._updateIdDefines();
						this._material.update();
				}
		}
		copyMaterialSettings(sourceMaterial) {
				const keysToDelete = [];
				this._material.defines.forEach((value, key)=>{
						if (!this._internalDefines.has(key)) {
								keysToDelete.push(key);
						}
				});
				keysToDelete.forEach((key)=>this._material.defines.delete(key));
				sourceMaterial.defines.forEach((value, key)=>{
						this._material.defines.set(key, value);
				});
				const srcParams = sourceMaterial.parameters;
				for(const paramName in srcParams){
						if (srcParams.hasOwnProperty(paramName)) {
								this._material.setParameter(paramName, srcParams[paramName].data);
						}
				}
				if (sourceMaterial.hasShaderChunks) {
						this._material.shaderChunks.copy(sourceMaterial.shaderChunks);
				}
				this._injectFormatChunks();
				this._material.update();
		}
		updateOverdrawMode(params) {
				const overdrawEnabled = !!params.colorRamp;
				const wasOverdrawEnabled = this._material.getDefine('GSPLAT_OVERDRAW');
				if (overdrawEnabled) {
						this._material.setParameter('colorRamp', params.colorRamp);
						this._material.setParameter('colorRampIntensity', params.colorRampIntensity);
				}
				if (overdrawEnabled !== wasOverdrawEnabled) {
						this._material.setDefine('GSPLAT_OVERDRAW', overdrawEnabled);
						if (overdrawEnabled) {
								this.originalBlendType = this._material.blendType;
								this._material.blendType = BLEND_ADDITIVE;
						} else {
								this._material.blendType = this.originalBlendType;
						}
						this._material.update();
				}
		}
		setMaxNumSplats(numSplats) {
				const roundedNumSplats = math.roundUp(numSplats, GSplatResourceBase.instanceSize);
				if (this.instanceIndicesCount < roundedNumSplats) {
						this.instanceIndicesCount = roundedNumSplats;
						this.instanceIndices?.destroy();
						this.instanceIndices = GSplatResourceBase.createInstanceIndices(this.device, numSplats);
						this.meshInstance.setInstancing(this.instanceIndices, true);
						this._material.setParameter('splatTextureSize', this.workBuffer.textureSize);
				}
		}
		createMeshInstance() {
				const mesh = GSplatResourceBase.createMesh(this.device);
				const textureSize = this.workBuffer.textureSize;
				const instanceIndices = GSplatResourceBase.createInstanceIndices(this.device, textureSize * textureSize);
				const meshInstance = new MeshInstance(mesh, this._material);
				meshInstance.node = this.node;
				meshInstance.setInstancing(instanceIndices, true);
				meshInstance.instancingCount = 0;
				const thisCamera = this.cameraNode.camera;
				meshInstance.isVisibleFunc = (camera)=>{
						const renderMode = this.renderMode ?? 0;
						if (thisCamera.camera === camera && renderMode & GSPLAT_FORWARD) {
								return true;
						}
						if (renderMode & GSPLAT_SHADOW) {
								return camera.node?.name === SHADOWCAMERA_NAME;
						}
						return false;
				};
				return meshInstance;
		}
		constructor(device, node, cameraNode, layer, workBuffer){
				this.instanceIndices = null;
				this.instanceIndicesCount = 0;
				this.originalBlendType = BLEND_ADDITIVE;
				this._internalDefines = new Set();
				this.forceCopyMaterial = true;
				this._workBufferFormatVersion = -1;
				this.device = device;
				this.node = node;
				this.cameraNode = cameraNode;
				this.layer = layer;
				this.workBuffer = workBuffer;
				this._workBufferFormatVersion = workBuffer.format.extraStreamsVersion;
				this._material = new ShaderMaterial({
						uniqueName: 'UnifiedSplatMaterial',
						vertexGLSL: '#include "gsplatVS"',
						fragmentGLSL: '#include "gsplatPS"',
						vertexWGSL: '#include "gsplatVS"',
						fragmentWGSL: '#include "gsplatPS"',
						attributes: {
								vertex_position: SEMANTIC_POSITION,
								vertex_id_attrib: SEMANTIC_ATTR13
						}
				});
				this.configureMaterial();
				this._material.defines.forEach((value, key)=>{
						this._internalDefines.add(key);
				});
				this._internalDefines.add('GSPLAT_UNIFIED_ID');
				this._internalDefines.add('PICK_CUSTOM_ID');
				this.meshInstance = this.createMeshInstance();
		}
}

export { GSplatRenderer };
