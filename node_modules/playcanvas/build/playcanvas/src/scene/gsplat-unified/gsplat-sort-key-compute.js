import { Vec3 } from '../../core/math/vec3.js';
import { Compute } from '../../platform/graphics/compute.js';
import { Shader } from '../../platform/graphics/shader.js';
import { StorageBuffer } from '../../platform/graphics/storage-buffer.js';
import { BindGroupFormat, BindTextureFormat, BindStorageBufferFormat, BindUniformBufferFormat } from '../../platform/graphics/bind-group-format.js';
import { UniformBufferFormat, UniformFormat } from '../../platform/graphics/uniform-buffer-format.js';
import { SHADERLANGUAGE_WGSL, UNIFORMTYPE_VEC3, UNIFORMTYPE_UINT, UNIFORMTYPE_FLOAT, SHADERSTAGE_COMPUTE, SAMPLETYPE_UINT, BUFFERUSAGE_COPY_SRC, BUFFERUSAGE_COPY_DST } from '../../platform/graphics/constants.js';
import { computeGsplatSortKeySource } from '../shader-lib/wgsl/chunks/gsplat/compute-gsplat-sort-key.js';
import { GSplatSortBinWeights } from './gsplat-sort-bin-weights.js';

const WORKGROUP_SIZE_X = 16;
const WORKGROUP_SIZE_Y = 16;
const THREADS_PER_WORKGROUP = WORKGROUP_SIZE_X * WORKGROUP_SIZE_Y;
const _cameraDir = new Vec3();
class GSplatSortKeyCompute {
		destroy() {
				this.keysBuffer?.destroy();
				this.binWeightsBuffer?.destroy();
				this.compute?.shader?.destroy();
				this.bindGroupFormat?.destroy();
				this.keysBuffer = null;
				this.binWeightsBuffer = null;
				this.compute = null;
				this.bindGroupFormat = null;
				this.uniformBufferFormat = null;
		}
		_getCompute(radialSort) {
				if (!this.compute || this.computeRadialSort !== radialSort) {
						this.compute?.shader?.destroy();
						const name = radialSort ? 'GSplatSortKeyCompute-Radial' : 'GSplatSortKeyCompute-Linear';
						const cdefines = new Map([
								[
										'{WORKGROUP_SIZE_X}',
										`${WORKGROUP_SIZE_X}`
								],
								[
										'{WORKGROUP_SIZE_Y}',
										`${WORKGROUP_SIZE_Y}`
								]
						]);
						if (radialSort) {
								cdefines.set('RADIAL_SORT', '');
						}
						const shader = new Shader(this.device, {
								name: name,
								shaderLanguage: SHADERLANGUAGE_WGSL,
								cshader: computeGsplatSortKeySource,
								cdefines: cdefines,
								computeEntryPoint: 'computeSortKey',
								computeBindGroupFormat: this.bindGroupFormat,
								computeUniformBufferFormats: {
										uniforms: this.uniformBufferFormat
								}
						});
						this.compute = new Compute(this.device, shader, name);
						this.computeRadialSort = radialSort;
				}
				return this.compute;
		}
		_createBindGroupFormat() {
				const device = this.device;
				this.uniformBufferFormat = new UniformBufferFormat(device, [
						new UniformFormat('cameraPosition', UNIFORMTYPE_VEC3),
						new UniformFormat('elementCount', UNIFORMTYPE_UINT),
						new UniformFormat('cameraDirection', UNIFORMTYPE_VEC3),
						new UniformFormat('numBits', UNIFORMTYPE_UINT),
						new UniformFormat('textureSize', UNIFORMTYPE_UINT),
						new UniformFormat('minDist', UNIFORMTYPE_FLOAT),
						new UniformFormat('invRange', UNIFORMTYPE_FLOAT),
						new UniformFormat('numWorkgroupsX', UNIFORMTYPE_UINT),
						new UniformFormat('numBins', UNIFORMTYPE_UINT)
				]);
				this.bindGroupFormat = new BindGroupFormat(device, [
						new BindTextureFormat('dataTransformA', SHADERSTAGE_COMPUTE, undefined, SAMPLETYPE_UINT, false),
						new BindStorageBufferFormat('sortKeys', SHADERSTAGE_COMPUTE, false),
						new BindUniformBufferFormat('uniforms', SHADERSTAGE_COMPUTE),
						new BindStorageBufferFormat('binWeights', SHADERSTAGE_COMPUTE, true)
				]);
		}
		_ensureCapacity(elementCount) {
				if (elementCount > this.allocatedCount) {
						this.keysBuffer?.destroy();
						this.allocatedCount = elementCount;
						this.keysBuffer = new StorageBuffer(this.device, elementCount * 4, BUFFERUSAGE_COPY_SRC);
				}
		}
		generate(workBuffer, cameraNode, radialSort, elementCount, numBits, minDist, maxDist) {
				this._ensureCapacity(elementCount);
				const workgroupCount = Math.ceil(elementCount / THREADS_PER_WORKGROUP);
				const numWorkgroupsX = Math.min(workgroupCount, this.device.limits.maxComputeWorkgroupsPerDimension || 65535);
				const numWorkgroupsY = Math.ceil(workgroupCount / numWorkgroupsX);
				const compute = this._getCompute(radialSort);
				const cameraPos = cameraNode.getPosition();
				const cameraMat = cameraNode.getWorldTransform();
				const cameraDir = cameraMat.getZ(_cameraDir).normalize();
				const range = maxDist - minDist;
				const invRange = range > 0 ? 1.0 / range : 1.0;
				const bucketCount = 1 << numBits;
				const cameraBin = GSplatSortBinWeights.computeCameraBin(radialSort, minDist, range);
				const binWeights = this.binWeightsUtil.compute(cameraBin, bucketCount);
				this.binWeightsBuffer.write(0, binWeights);
				compute.setParameter('dataTransformA', workBuffer.getTexture('dataTransformA'));
				compute.setParameter('sortKeys', this.keysBuffer);
				compute.setParameter('binWeights', this.binWeightsBuffer);
				this.cameraPositionData[0] = cameraPos.x;
				this.cameraPositionData[1] = cameraPos.y;
				this.cameraPositionData[2] = cameraPos.z;
				compute.setParameter('cameraPosition', this.cameraPositionData);
				this.cameraDirectionData[0] = cameraDir.x;
				this.cameraDirectionData[1] = cameraDir.y;
				this.cameraDirectionData[2] = cameraDir.z;
				compute.setParameter('cameraDirection', this.cameraDirectionData);
				compute.setParameter('elementCount', elementCount);
				compute.setParameter('numBits', numBits);
				compute.setParameter('textureSize', workBuffer.textureSize);
				compute.setParameter('minDist', minDist);
				compute.setParameter('invRange', invRange);
				compute.setParameter('numWorkgroupsX', numWorkgroupsX);
				compute.setParameter('numBins', GSplatSortBinWeights.NUM_BINS);
				compute.setupDispatch(numWorkgroupsX, numWorkgroupsY, 1);
				this.device.computeDispatch([
						compute
				], 'GSplatSortKeyCompute');
				return this.keysBuffer;
		}
		constructor(device){
				this.allocatedCount = 0;
				this.keysBuffer = null;
				this.binWeightsBuffer = null;
				this.compute = null;
				this.computeRadialSort = false;
				this.bindGroupFormat = null;
				this.uniformBufferFormat = null;
				this.cameraPositionData = new Float32Array(3);
				this.cameraDirectionData = new Float32Array(3);
				this.device = device;
				this.binWeightsUtil = new GSplatSortBinWeights();
				this.binWeightsBuffer = new StorageBuffer(device, GSplatSortBinWeights.NUM_BINS * 2 * 4, BUFFERUSAGE_COPY_SRC | BUFFERUSAGE_COPY_DST);
				this._createBindGroupFormat();
		}
}

export { GSplatSortKeyCompute };
