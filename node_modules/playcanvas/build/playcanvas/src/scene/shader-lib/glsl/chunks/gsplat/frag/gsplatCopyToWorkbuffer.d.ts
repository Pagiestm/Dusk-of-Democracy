declare const _default: "\n\n#define GSPLAT_CENTER_NOPROJ\n\n#include \"gsplatHelpersVS\"\n#include \"gsplatFormatVS\"\n#include \"gsplatStructsVS\"\n#include \"gsplatDeclarationsVS\"\n#include \"gsplatCenterVS\"\n#include \"gsplatEvalSHVS\"\n#include \"gsplatQuatToMat3VS\"\n#include \"gsplatReadVS\"\n#include \"gsplatWorkBufferOutputVS\"\n#include \"gsplatModifyVS\"\n\nuniform int uStartLine;      // Start row in destination texture\nuniform int uViewportWidth;  // Width of the destination viewport in pixels\n\n#ifdef GSPLAT_LOD\n    // LOD intervals texture\n    uniform usampler2D uIntervalsTexture;\n#endif\n\nuniform vec3 uColorMultiply;\n\n// number of splats\nuniform int uActiveSplats;\n\n// pre-computed model matrix decomposition\nuniform vec3 model_scale;\nuniform vec4 model_rotation;  // (x,y,z,w) format\n\n#ifdef GSPLAT_ID\n    uniform uint uId;\n#endif\n\nvoid main(void) {\n    // local fragment coordinates (within the viewport)\n    ivec2 localFragCoords = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y) - uStartLine);\n\n    // linear index of the splat\n    int targetIndex = localFragCoords.y * uViewportWidth + localFragCoords.x;\n    if (targetIndex >= uActiveSplats) {\n\n        // Out of bounds: write zeros\n        #ifdef GSPLAT_COLOR_UINT\n            writeDataColor(uvec4(0u));\n        #else\n            writeDataColor(vec4(0.0));\n        #endif\n        #ifndef GSPLAT_COLOR_ONLY\n            writeDataTransformA(uvec4(0u));\n            writeDataTransformB(uvec4(0u));\n        #endif\n\n    } else {\n\n        #ifdef GSPLAT_LOD\n            // Use intervals texture to remap target index to source index\n            int intervalsSize = int(textureSize(uIntervalsTexture, 0).x);\n            ivec2 intervalUV = ivec2(targetIndex % intervalsSize, targetIndex / intervalsSize);\n            uint originalIndex = texelFetch(uIntervalsTexture, intervalUV, 0).r;\n        #else\n            uint originalIndex = uint(targetIndex);\n        #endif\n        \n        // Initialize global splat for format read functions\n        setSplat(originalIndex);\n\n        // read center in local space\n        vec3 modelCenter = getCenter();\n\n        // compute world-space center for storage\n        vec3 worldCenter = (matrix_model * vec4(modelCenter, 1.0)).xyz;\n        SplatCenter center;\n        initCenter(modelCenter, center);\n\n        // Get source rotation and scale\n        // getRotation() returns (w,x,y,z) format, convert to (x,y,z,w) for quatMul\n        vec4 srcRotation = getRotation().yzwx;\n        vec3 srcScale = getScale();\n\n        // Combine: world = model * source (both in x,y,z,w format)\n        vec4 worldRotation = quatMul(model_rotation, srcRotation);\n        // Ensure w is positive so sqrt() reconstruction works correctly\n        // (quaternions q and -q represent the same rotation)\n        if (worldRotation.w < 0.0) {\n            worldRotation = -worldRotation;\n        }\n        vec3 worldScale = model_scale * srcScale;\n\n        // Apply custom center modification\n        vec3 originalCenter = worldCenter;\n        modifySplatCenter(worldCenter);\n\n        // Apply custom rotation/scale modification\n        modifySplatRotationScale(originalCenter, worldCenter, worldRotation, worldScale);\n\n        // read color\n        vec4 color = getColor();\n\n        // evaluate spherical harmonics\n        #if SH_BANDS > 0\n            // calculate the model-space view direction\n            vec3 dir = normalize(center.view * mat3(center.modelView));\n\n            // read sh coefficients\n            vec3 sh[SH_COEFFS];\n            float scale;\n            readSHData(sh, scale);\n\n            // evaluate\n            color.xyz += evalSH(sh, dir) * scale;\n        #endif\n\n        // Apply custom color modification\n        modifySplatColor(worldCenter, color);\n\n        color.xyz *= uColorMultiply;\n\n        // write out results using generated write functions\n        #ifdef GSPLAT_COLOR_UINT\n            // Pack RGBA as 4x half-float (16-bit) values for RGBA16U format\n            uint packed_rg = packHalf2x16(color.rg);\n            uint packed_ba = packHalf2x16(color.ba);\n            writeDataColor(uvec4(\n                packed_rg & 0xFFFFu,    // R as half\n                packed_rg >> 16u,       // G as half\n                packed_ba & 0xFFFFu,    // B as half\n                packed_ba >> 16u        // A as half\n            ));\n        #else\n            writeDataColor(color);\n        #endif\n        #ifndef GSPLAT_COLOR_ONLY\n            // Store rotation (xyz, w derived) and scale as 6 half-floats\n            writeDataTransformA(uvec4(floatBitsToUint(worldCenter.x), floatBitsToUint(worldCenter.y), floatBitsToUint(worldCenter.z), packHalf2x16(worldRotation.xy)));\n            writeDataTransformB(uvec4(packHalf2x16(vec2(worldRotation.z, worldScale.x)), packHalf2x16(worldScale.yz), 0u, 0u));\n        #endif\n\n        #ifdef GSPLAT_ID\n            writePcId(uvec4(uId, 0u, 0u, 0u));\n        #endif\n    }\n}\n";
export default _default;
