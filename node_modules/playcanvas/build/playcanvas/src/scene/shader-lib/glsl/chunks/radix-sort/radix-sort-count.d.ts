declare const _default: "\nuniform highp usampler2D keysTexture;\n\nuniform int bitsPerStep;\nuniform int groupSize;\nuniform int elementCount;\nuniform int imageElementsLog2;\nuniform int currentBit;\n\nvarying vec2 uv0;\n\n// Morton code functions for Z-order curve indexing\nuint interleaveWithZero(uint word) {\n    word = (word ^ (word << 8u)) & 0x00ff00ffu;\n    word = (word ^ (word << 4u)) & 0x0f0f0f0fu;\n    word = (word ^ (word << 2u)) & 0x33333333u;\n    word = (word ^ (word << 1u)) & 0x55555555u;\n    return word;\n}\n\nuint deinterleaveWithZero(uint word) {\n    word &= 0x55555555u;\n    word = (word | (word >> 1u)) & 0x33333333u;\n    word = (word | (word >> 2u)) & 0x0f0f0f0fu;\n    word = (word | (word >> 4u)) & 0x00ff00ffu;\n    word = (word | (word >> 8u)) & 0x0000ffffu;\n    return word;\n}\n\nivec2 indexToUV(uint index) {\n    return ivec2(deinterleaveWithZero(index), deinterleaveWithZero(index >> 1u));\n}\n\nuint uvToIndex(ivec2 uv) {\n    return interleaveWithZero(uint(uv.x)) | (interleaveWithZero(uint(uv.y)) << 1u);\n}\n\nvoid main() {\n    // Get current pixel position\n    ivec2 pixel = ivec2(gl_FragCoord.xy);\n    uint morton = uvToIndex(pixel);\n    \n    // Calculate which digit and which group this pixel represents\n    uint elementsLog2 = uint(imageElementsLog2);\n    uint groupsLog2 = elementsLog2 - uint(groupSize);\n    uint digitIndex = morton >> groupsLog2;\n    uint keyIndex = (morton - (digitIndex << groupsLog2)) << uint(groupSize);\n    uint elemCount = uint(elementCount);\n    \n    // Out of bounds check - this group starts past valid data\n    if (keyIndex >= elemCount) {\n        pcFragColor0 = 0.0;\n        return;\n    }\n    \n    // Setup variables for quad processing\n    uint count = 0u;\n    uint mask = (1u << uint(bitsPerStep)) - 1u;\n    uint cBit = uint(currentBit);\n    uvec4 digitIdx4 = uvec4(digitIndex);\n    uvec4 mask4 = uvec4(mask);\n    uvec4 elemCount4 = uvec4(elemCount);\n    const uvec4 QUAD_OFFSETS = uvec4(0u, 1u, 2u, 3u);\n    \n    // Check if this is a partial group (last group that extends past elementCount)\n    bool isPartialGroup = (keyIndex + 16u) > elemCount;\n    \n    #ifdef SOURCE_LINEAR\n        int sw = int(textureSize(keysTexture, 0).x);\n    #endif\n    \n    // Process all 4 quads (16 elements total per group)\n    // Use define/undef to control bounds checking at compile time\n    #define QUAD_COUNT 4\n    if (isPartialGroup) {\n        // Partial group: include bounds checking\n        #define BOUNDS_CHECK\n        #include \"radixSortCountQuad, QUAD_COUNT\"\n        #undef BOUNDS_CHECK\n    } else {\n        // Full group: no bounds checking needed (fast path)\n        #include \"radixSortCountQuad, QUAD_COUNT\"\n    }\n    \n    // Output the count as raw float (R32F format)\n    pcFragColor0 = float(count);\n}\n";
export default _default;
