declare const _default: "\nuniform vec4 viewport_size;             // viewport width, height, 1/width, 1/height\n\n// compute 3d covariance from rotation (w,x,y,z format) and scale\nvoid computeCovariance(vec4 rotation, vec3 scale, out vec3 covA, out vec3 covB) {\n    mat3 rot = quatToMat3(rotation);\n\n    // M = S * R\n    mat3 M = transpose(mat3(\n        scale.x * rot[0],\n        scale.y * rot[1],\n        scale.z * rot[2]\n    ));\n\n    covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n    covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n\n// calculate the clip-space offset from the center for this gaussian\nbool initCornerCov(SplatSource source, SplatCenter center, out SplatCorner corner, vec3 covA, vec3 covB) {\n\n    mat3 Vrk = mat3(\n        covA.x, covA.y, covA.z, \n        covA.y, covB.x, covB.y,\n        covA.z, covB.y, covB.z\n    );\n\n    float focal = viewport_size.x * center.projMat00;\n\n    vec3 v = camera_params.w == 1.0 ? vec3(0.0, 0.0, 1.0) : center.view.xyz;\n    float J1 = focal / v.z;\n    vec2 J2 = -J1 / v.z * v.xy;\n    mat3 J = mat3(\n        J1, 0.0, J2.x, \n        0.0, J1, J2.y, \n        0.0, 0.0, 0.0\n    );\n\n    mat3 W = transpose(mat3(center.modelView));\n    mat3 T = W * J;\n    mat3 cov = transpose(T) * Vrk * T;\n\n    #if GSPLAT_AA\n        // calculate AA factor\n        float detOrig = cov[0][0] * cov[1][1] - cov[0][1] * cov[0][1];\n        float detBlur = (cov[0][0] + 0.3) * (cov[1][1] + 0.3) - cov[0][1] * cov[0][1];\n        corner.aaFactor = sqrt(max(detOrig / detBlur, 0.0));\n    #endif\n\n    float diagonal1 = cov[0][0] + 0.3;\n    float offDiagonal = cov[0][1];\n    float diagonal2 = cov[1][1] + 0.3;\n\n    float mid = 0.5 * (diagonal1 + diagonal2);\n    float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n    float lambda1 = mid + radius;\n    float lambda2 = max(mid - radius, 0.1);\n\n    // Use the smaller viewport dimension to limit the kernel size relative to the screen resolution.\n    float vmin = min(1024.0, min(viewport_size.x, viewport_size.y));\n\n    float l1 = 2.0 * min(sqrt(2.0 * lambda1), vmin);\n    float l2 = 2.0 * min(sqrt(2.0 * lambda2), vmin);\n\n    // early-out gaussians smaller than 2 pixels\n    if (l1 < 2.0 && l2 < 2.0) {\n        return false;\n    }\n\n    vec2 c = center.proj.ww * viewport_size.zw;\n\n    // cull against frustum x/y axes\n    if (any(greaterThan(abs(center.proj.xy) - vec2(max(l1, l2)) * c, center.proj.ww))) {\n        return false;\n    }\n\n    vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n    vec2 v1 = l1 * diagonalVector;\n    vec2 v2 = l2 * vec2(diagonalVector.y, -diagonalVector.x);\n\n    corner.offset = vec3((source.cornerUV.x * v1 + source.cornerUV.y * v2) * c, 0.0);\n    corner.uv = source.cornerUV;\n\n    return true;\n}\n\n#if GSPLAT_2DGS\n// 2DGS: Compute oriented quad corner in model space\nvoid initCorner2DGS(SplatSource source, vec4 rotation, vec3 scale, out SplatCorner corner) {\n    // Scale by 3.0 for 3-sigma coverage\n    vec2 localPos = source.cornerUV * vec2(scale.x, scale.y) * 3.0;\n\n    // Rotate the local position using the quaternion\n    vec3 v = vec3(localPos, 0.0);\n    vec3 t = 2.0 * cross(rotation.xyz, v);\n    corner.offset = v + rotation.w * t + cross(rotation.xyz, t);\n    corner.uv = source.cornerUV;\n}\n#endif\n\n// calculate the clip-space offset from the center for this gaussian\nbool initCorner(SplatSource source, SplatCenter center, out SplatCorner corner) {\n    // Get rotation and scale\n    vec4 rotation = getRotation().yzwx;  // Convert (w,x,y,z) to (x,y,z,w)\n    vec3 scale = getScale();\n\n    // Hook: modify rotation and scale\n    modifySplatRotationScale(center.modelCenterOriginal, center.modelCenterModified, rotation, scale);\n\n    #if GSPLAT_2DGS\n        initCorner2DGS(source, rotation, scale, corner);\n        return true;\n    #else\n        // 3DGS: Use covariance-based screen-space projection\n        // Compute covariance from (possibly modified) rotation and scale\n        vec3 covA, covB;\n        computeCovariance(rotation.wxyz, scale, covA, covB);  // Convert back to (w,x,y,z)\n\n        return initCornerCov(source, center, corner, covA, covB);\n    #endif\n}\n";
export default _default;
