var glslRadixSortCountPS = `
uniform highp usampler2D keysTexture;
uniform int bitsPerStep;
uniform int groupSize;
uniform int elementCount;
uniform int imageElementsLog2;
uniform int currentBit;
varying vec2 uv0;
uint interleaveWithZero(uint word) {
	word = (word ^ (word << 8u)) & 0x00ff00ffu;
	word = (word ^ (word << 4u)) & 0x0f0f0f0fu;
	word = (word ^ (word << 2u)) & 0x33333333u;
	word = (word ^ (word << 1u)) & 0x55555555u;
	return word;
}
uint deinterleaveWithZero(uint word) {
	word &= 0x55555555u;
	word = (word | (word >> 1u)) & 0x33333333u;
	word = (word | (word >> 2u)) & 0x0f0f0f0fu;
	word = (word | (word >> 4u)) & 0x00ff00ffu;
	word = (word | (word >> 8u)) & 0x0000ffffu;
	return word;
}
ivec2 indexToUV(uint index) {
	return ivec2(deinterleaveWithZero(index), deinterleaveWithZero(index >> 1u));
}
uint uvToIndex(ivec2 uv) {
	return interleaveWithZero(uint(uv.x)) | (interleaveWithZero(uint(uv.y)) << 1u);
}
void main() {
	ivec2 pixel = ivec2(gl_FragCoord.xy);
	uint morton = uvToIndex(pixel);
	
	uint elementsLog2 = uint(imageElementsLog2);
	uint groupsLog2 = elementsLog2 - uint(groupSize);
	uint digitIndex = morton >> groupsLog2;
	uint keyIndex = (morton - (digitIndex << groupsLog2)) << uint(groupSize);
	uint elemCount = uint(elementCount);
	
	if (keyIndex >= elemCount) {
		pcFragColor0 = 0.0;
		return;
	}
	
	uint count = 0u;
	uint mask = (1u << uint(bitsPerStep)) - 1u;
	uint cBit = uint(currentBit);
	uvec4 digitIdx4 = uvec4(digitIndex);
	uvec4 mask4 = uvec4(mask);
	uvec4 elemCount4 = uvec4(elemCount);
	const uvec4 QUAD_OFFSETS = uvec4(0u, 1u, 2u, 3u);
	
	bool isPartialGroup = (keyIndex + 16u) > elemCount;
	
	#ifdef SOURCE_LINEAR
		int sw = int(textureSize(keysTexture, 0).x);
	#endif
	
	#define QUAD_COUNT 4
	if (isPartialGroup) {
		#define BOUNDS_CHECK
		#include "radixSortCountQuad, QUAD_COUNT"
		#undef BOUNDS_CHECK
	} else {
		#include "radixSortCountQuad, QUAD_COUNT"
	}
	
	pcFragColor0 = float(count);
}
`;

export { glslRadixSortCountPS as default };
