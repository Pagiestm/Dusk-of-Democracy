declare const _default: "\nuniform highp usampler2D keysTexture;\n#ifdef SOURCE_LINEAR\n    #define FIRST_PASS\n#else\n    uniform highp usampler2D indicesTexture;\n#endif\n\nuniform highp sampler2D prefixSums;\nuniform int bitsPerStep;\nuniform int groupSize;\nuniform int elementCount;\nuniform int imageElementsLog2;\nuniform int currentBit;\nuniform int imageSize;\n\nvarying vec2 uv0;\n\n// Morton code functions for Z-order curve indexing\nuint interleaveWithZero(uint word) {\n    word = (word ^ (word << 8u)) & 0x00ff00ffu;\n    word = (word ^ (word << 4u)) & 0x0f0f0f0fu;\n    word = (word ^ (word << 2u)) & 0x33333333u;\n    word = (word ^ (word << 1u)) & 0x55555555u;\n    return word;\n}\n\nuint deinterleaveWithZero(uint word) {\n    word &= 0x55555555u;\n    word = (word | (word >> 1u)) & 0x33333333u;\n    word = (word | (word >> 2u)) & 0x0f0f0f0fu;\n    word = (word | (word >> 4u)) & 0x00ff00ffu;\n    word = (word | (word >> 8u)) & 0x0000ffffu;\n    return word;\n}\n\nivec2 indexToUV(uint index) {\n    return ivec2(deinterleaveWithZero(index), deinterleaveWithZero(index >> 1u));\n}\n\nuint uvToIndex(ivec2 uv) {\n    return interleaveWithZero(uint(uv.x)) | (interleaveWithZero(uint(uv.y)) << 1u);\n}\n\n// Count active texels at a given mip level\n// R32F format stores raw counts, mipmaps store averages\n// Multiply by 4^level to convert average back to sum\n// Uses bit shift instead of pow() for performance\nfloat countActiveTexels(ivec3 uv, ivec2 offset) {\n    // 4^level = 2^(level*2) = 1 << (level * 2)\n    float scale = float(1u << (uint(uv.z) * 2u));\n    return scale * texelFetch(prefixSums, uv.xy + offset, uv.z).r;\n}\n\n// Binary search through the mipmap hierarchy to find which source texel\n// maps to the given destination index\nivec2 activeTexelIndexToUV(float prefixWidth, float index, out float activePrevTexelSum) {\n    float maxLod = round(log2(prefixWidth));\n    ivec3 uv = ivec3(0, 0, int(maxLod));\n    \n    float countTotal = countActiveTexels(uv, ivec2(0, 0));\n    activePrevTexelSum = 0.0;\n    \n    // Out of bounds check\n    if (index >= countTotal) {\n        activePrevTexelSum = countTotal;\n        return ivec2(-1, -1);\n    }\n    \n    // Traverse down the mipmap hierarchy\n    while (uv.z >= 1) {\n        uv = ivec3(uv.xy * 2, uv.z - 1);\n        \n        float count00 = countActiveTexels(uv, ivec2(0, 0));\n        float count01 = countActiveTexels(uv, ivec2(1, 0));\n        float count10 = countActiveTexels(uv, ivec2(0, 1));\n        \n        float sum00 = activePrevTexelSum + count00;\n        float sum01 = sum00 + count01;\n        float sum10 = sum01 + count10;\n        \n        bool in00 = index < sum00;\n        bool in01 = index < sum01;\n        bool in10 = index < sum10;\n        \n        if (in00) {\n            // Stay at (0,0)\n        } else if (in01) {\n            uv.xy += ivec2(1, 0);\n            activePrevTexelSum += count00;\n        } else if (in10) {\n            uv.xy += ivec2(0, 1);\n            activePrevTexelSum += count00 + count01;\n        } else {\n            uv.xy += ivec2(1, 1);\n            activePrevTexelSum += count00 + count01 + count10;\n        }\n    }\n    \n    return uv.xy;\n}\n\nvoid main() {\n    ivec2 pixel = ivec2(gl_FragCoord.xy);\n    \n    #ifdef OUTPUT_LINEAR\n        // Linear index for output (simpler for consumers to read)\n        uint index = uint(pixel.y) * uint(imageSize) + uint(pixel.x);\n    #else\n        // Morton index for internal passes (better cache locality)\n        uint index = uvToIndex(pixel);\n    #endif\n    \n    // Out of bounds check\n    if (index >= uint(elementCount)) {\n        pcFragColor0 = uvec4(0xFFFFFFFFu, 0u, 0u, 1u);\n        pcFragColor1 = uvec4(0xFFFFFFFFu, 0u, 0u, 1u);\n        return;\n    }\n    \n    // Calculate prefix sum texture dimensions\n    float prefixWidth = float(imageSize * (1 << (bitsPerStep >> 1))) / float(1 << (groupSize >> 1));\n    \n    // Binary search through mipmaps\n    float count;\n    ivec2 activePixel = activeTexelIndexToUV(prefixWidth, float(index), count);\n    \n    if (activePixel.x < 0) {\n        pcFragColor0 = uvec4(0xFFFFFFFFu, 0u, 0u, 1u);\n        pcFragColor1 = uvec4(0xFFFFFFFFu, 0u, 0u, 1u);\n        return;\n    }\n    \n    // Convert active pixel back to key index and digit\n    uint activeIndex = uvToIndex(activePixel);\n    uint elementsLog2 = uint(imageElementsLog2);\n    uint groupsLog2 = elementsLog2 - uint(groupSize);\n    uint digitIndex = activeIndex >> groupsLog2;\n    uint keyIndex = (activeIndex - (digitIndex << groupsLog2)) << uint(groupSize);\n    \n    // Linear search within the group - optimized with integer math and incremental coords\n    uint outKey = 0u;\n    uint mask = (1u << uint(bitsPerStep)) - 1u;\n    uint localIndexU = uint(float(index) - count);\n    uint localCountU = 0u;\n    uint foundMortonIndex = keyIndex;\n    \n    #ifdef SOURCE_LINEAR\n        // Compute starting (x,y) once - only 1 div/mod instead of 16\n        uint sw = uint(textureSize(keysTexture, 0).x);\n        uint baseY = keyIndex / sw;\n        uint baseX = keyIndex - baseY * sw;\n        uint x = baseX;\n        uint y = baseY;\n        \n        for (uint i = 0u; i < 16u; ++i) {\n            ivec2 groupPixel = ivec2(int(x), int(y));\n            outKey = texelFetch(keysTexture, groupPixel, 0).r;\n            \n            uint digit = (outKey >> uint(currentBit)) & mask;\n            \n            if (digit == digitIndex) {\n                localCountU++;\n                if (localCountU > localIndexU) {\n                    foundMortonIndex = keyIndex + i;\n                    break;\n                }\n            }\n            \n            // Advance to next pixel with wrap\n            x++;\n            if (x >= sw) {\n                x = 0u;\n                y++;\n            }\n        }\n    #else\n        // Morton layout - can't use simple x++ increment, but still use integer math\n        for (uint i = 0u; i < 16u; ++i) {\n            uint mortonIndex = keyIndex + i;\n            ivec2 groupPixel = indexToUV(mortonIndex);\n            outKey = texelFetch(keysTexture, groupPixel, 0).r;\n            \n            uint digit = (outKey >> uint(currentBit)) & mask;\n            \n            if (digit == digitIndex) {\n                localCountU++;\n                if (localCountU > localIndexU) {\n                    foundMortonIndex = mortonIndex;\n                    break;\n                }\n            }\n        }\n    #endif\n    \n    // Read indices after finding the match\n    #ifdef FIRST_PASS\n        // First pass: indices are implicitly [0,1,2,...], use index directly\n        uint outIndex = foundMortonIndex;\n    #else\n        // Subsequent passes: read from shuffled indices texture\n        ivec2 indicesPixel = indexToUV(foundMortonIndex);\n        uint outIndex = texelFetch(indicesTexture, indicesPixel, 0).r;\n    #endif\n    \n    // Output to two render targets (MRT): keys (uint) and indices (uint)\n    pcFragColor0 = uvec4(outKey, 0u, 0u, 1u);\n    pcFragColor1 = uvec4(outIndex, 0u, 0u, 1u);\n}\n";
export default _default;
