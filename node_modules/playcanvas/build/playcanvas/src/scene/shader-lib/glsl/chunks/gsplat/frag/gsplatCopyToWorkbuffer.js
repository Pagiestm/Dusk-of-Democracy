var glslGsplatCopyToWorkBufferPS = `
#define GSPLAT_CENTER_NOPROJ
#include "gsplatHelpersVS"
#include "gsplatFormatVS"
#include "gsplatStructsVS"
#include "gsplatDeclarationsVS"
#include "gsplatCenterVS"
#include "gsplatEvalSHVS"
#include "gsplatQuatToMat3VS"
#include "gsplatReadVS"
#include "gsplatWorkBufferOutputVS"
#include "gsplatModifyVS"
uniform int uStartLine;
uniform int uViewportWidth;
#ifdef GSPLAT_LOD
	uniform usampler2D uIntervalsTexture;
#endif
uniform vec3 uColorMultiply;
uniform int uActiveSplats;
uniform vec3 model_scale;
uniform vec4 model_rotation;
#ifdef GSPLAT_ID
	uniform uint uId;
#endif
void main(void) {
	ivec2 localFragCoords = ivec2(int(gl_FragCoord.x), int(gl_FragCoord.y) - uStartLine);
	int targetIndex = localFragCoords.y * uViewportWidth + localFragCoords.x;
	if (targetIndex >= uActiveSplats) {
		#ifdef GSPLAT_COLOR_UINT
			writeDataColor(uvec4(0u));
		#else
			writeDataColor(vec4(0.0));
		#endif
		#ifndef GSPLAT_COLOR_ONLY
			writeDataTransformA(uvec4(0u));
			writeDataTransformB(uvec4(0u));
		#endif
	} else {
		#ifdef GSPLAT_LOD
			int intervalsSize = int(textureSize(uIntervalsTexture, 0).x);
			ivec2 intervalUV = ivec2(targetIndex % intervalsSize, targetIndex / intervalsSize);
			uint originalIndex = texelFetch(uIntervalsTexture, intervalUV, 0).r;
		#else
			uint originalIndex = uint(targetIndex);
		#endif
		
		setSplat(originalIndex);
		vec3 modelCenter = getCenter();
		vec3 worldCenter = (matrix_model * vec4(modelCenter, 1.0)).xyz;
		SplatCenter center;
		initCenter(modelCenter, center);
		vec4 srcRotation = getRotation().yzwx;
		vec3 srcScale = getScale();
		vec4 worldRotation = quatMul(model_rotation, srcRotation);
		if (worldRotation.w < 0.0) {
			worldRotation = -worldRotation;
		}
		vec3 worldScale = model_scale * srcScale;
		vec3 originalCenter = worldCenter;
		modifySplatCenter(worldCenter);
		modifySplatRotationScale(originalCenter, worldCenter, worldRotation, worldScale);
		vec4 color = getColor();
		#if SH_BANDS > 0
			vec3 dir = normalize(center.view * mat3(center.modelView));
			vec3 sh[SH_COEFFS];
			float scale;
			readSHData(sh, scale);
			color.xyz += evalSH(sh, dir) * scale;
		#endif
		modifySplatColor(worldCenter, color);
		color.xyz *= uColorMultiply;
		#ifdef GSPLAT_COLOR_UINT
			uint packed_rg = packHalf2x16(color.rg);
			uint packed_ba = packHalf2x16(color.ba);
			writeDataColor(uvec4(
				packed_rg & 0xFFFFu,
				packed_rg >> 16u,
				packed_ba & 0xFFFFu,
				packed_ba >> 16u
			));
		#else
			writeDataColor(color);
		#endif
		#ifndef GSPLAT_COLOR_ONLY
			writeDataTransformA(uvec4(floatBitsToUint(worldCenter.x), floatBitsToUint(worldCenter.y), floatBitsToUint(worldCenter.z), packHalf2x16(worldRotation.xy)));
			writeDataTransformB(uvec4(packHalf2x16(vec2(worldRotation.z, worldScale.x)), packHalf2x16(worldScale.yz), 0u, 0u));
		#endif
		#ifdef GSPLAT_ID
			writePcId(uvec4(uId, 0u, 0u, 0u));
		#endif
	}
}
`;

export { glslGsplatCopyToWorkBufferPS as default };
