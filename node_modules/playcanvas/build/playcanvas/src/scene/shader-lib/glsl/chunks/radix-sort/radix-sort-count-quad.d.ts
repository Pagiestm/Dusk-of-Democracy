declare const _default: "\n\n// ============================================\n// Quad {i}: Process elements at offset {i} * 4\n// ============================================\n{\n    // Calculate element indices for this quad\n    uint base = {i}u * 4u;\n    uvec4 mi4 = (keyIndex + base) + QUAD_OFFSETS;\n\n    // Load keys from texture - different coordinate calculation per variant\n    #ifdef SOURCE_LINEAR\n        // Linear layout: convert linear index to 2D coordinates\n        uvec4 y4 = mi4 / uint(sw);\n        uvec4 x4 = mi4 - y4 * uint(sw);\n        uvec4 keys = uvec4(\n            texelFetch(keysTexture, ivec2(x4.x, y4.x), 0).r,\n            texelFetch(keysTexture, ivec2(x4.y, y4.y), 0).r,\n            texelFetch(keysTexture, ivec2(x4.z, y4.z), 0).r,\n            texelFetch(keysTexture, ivec2(x4.w, y4.w), 0).r\n        );\n    #else\n        // Morton layout: use Z-order curve lookup\n        uvec4 keys = uvec4(\n            texelFetch(keysTexture, indexToUV(mi4.x), 0).r,\n            texelFetch(keysTexture, indexToUV(mi4.y), 0).r,\n            texelFetch(keysTexture, indexToUV(mi4.z), 0).r,\n            texelFetch(keysTexture, indexToUV(mi4.w), 0).r\n        );\n    #endif\n\n    // Extract digits and count matches\n    uvec4 digits = (keys >> cBit) & mask4;\n    uvec4 m4 = uvec4(equal(digits, digitIdx4));\n\n    // Bounds checking - only included for partial groups (last group)\n    #ifdef BOUNDS_CHECK\n        // Zero out counts for elements past elementCount\n        m4 *= uvec4(lessThan(mi4, elemCount4));\n    #endif\n\n    // Accumulate count\n    count += m4.x + m4.y + m4.z + m4.w;\n}\n";
export default _default;
