declare const _default: "\nfn evaluateBackend() -> FragmentOutput {\n\n    var output: FragmentOutput;\n\n    // apply SSAO during lighting\n    #ifdef LIT_SSAO\n        litArgs_ao = litArgs_ao * textureSampleLevel(ssaoTexture, ssaoTextureSampler, pcPosition.xy * uniform.ssaoTextureSizeInv, 0.0).r;\n    #endif\n\n    // transform tangent space normals to world space\n    #ifdef LIT_NEEDS_NORMAL\n        #ifdef LIT_SPECULAR\n            getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);\n        #endif\n\n        #ifdef LIT_CLEARCOAT\n            ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));\n        #endif\n    #endif\n\n    #ifdef LIT_SPECULAR_OR_REFLECTION\n        #ifdef LIT_METALNESS\n            var f0: f32 = 1.0 / litArgs_ior;\n            f0 = (f0 - 1.0) / (f0 + 1.0);\n            f0 = f0 * f0;\n            #ifdef LIT_SPECULARITY_FACTOR\n                litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0, litArgs_specularityFactor);\n            #else\n                litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0, 1.0);\n            #endif\n            litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);\n        #endif\n\n        #ifdef LIT_IRIDESCENCE\n            var iridescenceFresnel: vec3f = getIridescenceDiffraction(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);\n        #endif\n    #endif\n\n    // ambient\n    #ifdef LIT_ADD_AMBIENT\n        addAmbient(litArgs_worldNormal);\n\n        #ifdef LIT_SPECULAR\n            dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);\n        #endif\n\n        // move ambient color out of diffuse (used by Lightmapper, to multiply ambient color by accumulated AO)\n        #ifdef LIT_SEPARATE_AMBIENT\n            var dAmbientLight: vec3f = dDiffuseLight;\n            dDiffuseLight = vec3(0.0);\n        #endif\n    #endif\n\n    #ifndef LIT_OLD_AMBIENT\n        dDiffuseLight = dDiffuseLight * uniform.material_ambient;\n    #endif\n\n    #ifdef LIT_AO\n        #ifndef LIT_OCCLUDE_DIRECT\n            occludeDiffuse(litArgs_ao);\n        #endif\n    #endif\n\n    #ifdef LIT_LIGHTMAP\n        addLightMap(\n            litArgs_lightmap, \n            litArgs_lightmapDir, \n            litArgs_worldNormal, \n            dViewDirW, \n            dReflDirW, \n            litArgs_gloss, \n            litArgs_specularity, \n            dVertexNormalW,\n            dTBN\n        #if defined(LIT_IRIDESCENCE)\n            , iridescenceFresnel,\n            litArgs_iridescence_intensity\n        #endif\n        );\n    #endif\n\n    #ifdef LIT_LIGHTING || LIT_REFLECTIONS\n\n        #ifdef LIT_REFLECTIONS\n\n            #ifdef LIT_CLEARCOAT\n                addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);\n            \n                #ifdef LIT_SPECULAR_FRESNEL\n                    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));\n                    ccReflection = ccReflection * ccFresnel;\n                #else\n                    ccFresnel = 0.0;\n                #endif\n            #endif\n\n            #ifdef LIT_SPECULARITY_FACTOR\n                ccReflection = ccReflection * litArgs_specularityFactor;\n            #endif\n\n            #ifdef LIT_SHEEN\n                addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);\n            #endif\n\n            // Fresnel has to be applied to reflections\n            addReflection(dReflDirW, litArgs_gloss);\n\n            #ifdef LIT_FRESNEL_MODEL\n\n                dReflection = vec4f(\n                    dReflection.rgb * getFresnel(\n                        dot(dViewDirW, litArgs_worldNormal),\n                        litArgs_gloss,\n                        litArgs_specularity\n                    #if defined(LIT_IRIDESCENCE)\n                        , iridescenceFresnel,\n                        litArgs_iridescence_intensity\n                    #endif\n                        ),\n                    dReflection.a\n                );\n\n            #else\n\n                dReflection = vec4f(dReflection.rgb * litArgs_specularity, dReflection.a);\n\n            #endif\n\n        #endif\n\n        #ifdef AREA_LIGHTS\n            // specular has to be accumulated differently if we want area lights to look correct\n            dSpecularLight = dSpecularLight * litArgs_specularity;\n\n            #ifdef LIT_SPECULAR\n                // evaluate material based area lights data, shared by all area lights\n                calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);\n            #endif\n        #endif\n        \n        // LOOP - evaluate all non-clustered lights\n        #ifdef LIGHT_COUNT > 0\n            #include \"lightEvaluationPS, LIGHT_COUNT\"\n        #endif\n\n        // clustered lighting\n        #ifdef LIT_CLUSTERED_LIGHTS\n            addClusteredLights(litArgs_worldNormal, dViewDirW, dReflDirW,\n                #if defined(LIT_CLEARCOAT)\n                        ccReflDirW,\n                #endif\n                        litArgs_gloss, litArgs_specularity, dVertexNormalW, dTBN, \n                #if defined(LIT_IRIDESCENCE)\n                        iridescenceFresnel,\n                #endif\n                        litArgs_clearcoat_worldNormal, litArgs_clearcoat_gloss, litArgs_sheen_gloss, litArgs_iridescence_intensity\n            );\n        #endif\n\n        #ifdef AREA_LIGHTS\n\n            #ifdef LIT_CLEARCOAT\n                // specular has to be accumulated differently if we want area lights to look correct\n                litArgs_clearcoat_specularity = 1.0;\n            #endif\n\n            #ifdef LIT_SPECULAR\n                litArgs_specularity = vec3(1.0);\n            #endif\n\n        #endif\n\n        #ifdef LIT_REFRACTION\n            addRefraction(\n                litArgs_worldNormal, \n                dViewDirW, \n                litArgs_thickness, \n                litArgs_gloss, \n                litArgs_specularity, \n                litArgs_albedo, \n                litArgs_transmission,\n                litArgs_ior,\n                litArgs_dispersion\n                #if defined(LIT_IRIDESCENCE)\n                    , iridescenceFresnel, \n                    litArgs_iridescence_intensity\n                #endif\n            );\n        #endif\n    #endif\n\n    // apply ambient occlusion\n    #ifdef LIT_AO\n        #ifdef LIT_OCCLUDE_DIRECT\n            occludeDiffuse(litArgs_ao);\n        #endif\n\n        #if LIT_OCCLUDE_SPECULAR != NONE\n            occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);\n        #endif\n    #endif\n\n    #if !defined(LIT_OPACITY_FADES_SPECULAR)\n\n        #if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == PREMULTIPLIED\n\n            var specLum: f32 = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3f( 0.2126, 0.7152, 0.0722 ));\n            #ifdef LIT_CLEARCOAT\n                specLum = specLum + dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection * litArgs_clearcoat_specularity, vec3f( 0.2126, 0.7152, 0.0722 ));\n            #endif\n            litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);\n\n        #endif\n\n        litArgs_opacity = litArgs_opacity * uniform.material_alphaFade;\n\n    #endif\n\n    // end chunks - when baking lightmap\n    #ifdef LIT_LIGHTMAP_BAKING\n        #ifdef LIT_LIGHTMAP_BAKING_COLOR\n            #include \"bakeLmEndPS\"\n        #endif\n        #ifdef LIT_LIGHTMAP_BAKING_DIR\n            #include \"bakeDirLmEndPS\"\n        #endif\n    #else\n        // end chunks - in all other cases\n        #include \"endPS\"\n        #include \"outputAlphaPS\"\n    #endif\n\n    #ifdef LIT_MSDF\n        output.color = applyMsdf(output.color);\n    #endif\n\n    #include \"outputPS\"\n    #include \"debugOutputPS\"\n\n    #ifdef LIT_SHADOW_CATCHER\n        // output when the shadow catcher is enabled - accumulated shadows\n        output.color = vec4f(vec3f(dShadowCatcher), output.color.a);\n    #endif\n\n    return output;\n}\n";
export default _default;
