declare const _default: "\nuniform viewport_size: vec4f;             // viewport width, height, 1/width, 1/height\n\n// compute 3d covariance from rotation (w,x,y,z format) and scale\nfn computeCovariance(rotation: vec4f, scale: vec3f, covA_ptr: ptr<function, vec3f>, covB_ptr: ptr<function, vec3f>) {\n    let rot = quatToMat3(rotation);\n\n    // M = S * R\n    let M = transpose(mat3x3f(\n        scale.x * rot[0],\n        scale.y * rot[1],\n        scale.z * rot[2]\n    ));\n\n    *covA_ptr = vec3f(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n    *covB_ptr = vec3f(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n\n// calculate the clip-space offset from the center for this gaussian\nfn initCornerCov(source: ptr<function, SplatSource>, center: ptr<function, SplatCenter>, corner: ptr<function, SplatCorner>, covA: vec3f, covB: vec3f) -> bool {\n\n    let Vrk = mat3x3f(\n        vec3f(covA.x, covA.y, covA.z),\n        vec3f(covA.y, covB.x, covB.y),\n        vec3f(covA.z, covB.y, covB.z)\n    );\n\n    let focal = uniform.viewport_size.x * center.projMat00;\n\n    let v = select(center.view.xyz, vec3f(0.0, 0.0, 1.0), uniform.camera_params.w == 1.0);\n    let J1 = focal / v.z;\n    let J2 = -J1 / v.z * v.xy;\n    let J = mat3x3f(\n        vec3f(J1, 0.0, J2.x),\n        vec3f(0.0, J1, J2.y),\n        vec3f(0.0, 0.0, 0.0)\n    );\n\n    let W = transpose(mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));\n    let T = W * J;\n    let cov = transpose(T) * Vrk * T;\n\n    #if GSPLAT_AA\n        // calculate AA factor\n        let detOrig = cov[0][0] * cov[1][1] - cov[0][1] * cov[1][0]; // Using [0][1] * [1][0] as matrix might not be perfectly symmetric numerically\n        let detBlur = (cov[0][0] + 0.3) * (cov[1][1] + 0.3) - cov[0][1] * cov[1][0];\n        corner.aaFactor = sqrt(detOrig / detBlur);\n    #endif\n\n    let diagonal1 = cov[0][0] + 0.3;\n    let offDiagonal = cov[0][1];\n    let diagonal2 = cov[1][1] + 0.3;\n\n    let mid = 0.5 * (diagonal1 + diagonal2);\n    let radius = length(vec2f((diagonal1 - diagonal2) / 2.0, offDiagonal));\n    let lambda1 = mid + radius;\n    let lambda2 = max(mid - radius, 0.1);\n\n    // Use the smaller viewport dimension to limit the kernel size relative to the screen resolution.\n    let vmin = min(1024.0, min(uniform.viewport_size.x, uniform.viewport_size.y));\n\n    let l1 = 2.0 * min(sqrt(2.0 * lambda1), vmin);\n    let l2 = 2.0 * min(sqrt(2.0 * lambda2), vmin);\n\n    // early-out gaussians smaller than 2 pixels\n    if (l1 < 2.0 && l2 < 2.0) {\n        return false;\n    }\n\n    let c = center.proj.ww * uniform.viewport_size.zw;\n\n    // cull against frustum x/y axes\n    if (any((abs(center.proj.xy) - vec2f(max(l1, l2)) * c) > center.proj.ww)) {\n        return false;\n    }\n\n    let diagonalVector = normalize(vec2f(offDiagonal, lambda1 - diagonal1));\n    let v1 = l1 * diagonalVector;\n    let v2 = l2 * vec2f(diagonalVector.y, -diagonalVector.x); // Swizzle\n\n    corner.offset = vec3f((source.cornerUV.x * v1 + source.cornerUV.y * v2) * c, 0.0);\n    corner.uv = source.cornerUV;\n\n    return true;\n}\n\n#if GSPLAT_2DGS\n// 2DGS: Compute oriented quad corner in model space\nfn initCorner2DGS(source: ptr<function, SplatSource>, rotation: vec4f, scale: vec3f, corner: ptr<function, SplatCorner>) {\n    // Scale by 3.0 for 3-sigma coverage\n    let localPos: vec2f = source.cornerUV * vec2f(scale.x, scale.y) * 3.0;\n\n    // Rotate the local position using the quaternion\n    let v: vec3f = vec3f(localPos, 0.0);\n    let t: vec3f = 2.0 * cross(rotation.xyz, v);\n    corner.offset = v + rotation.w * t + cross(rotation.xyz, t);\n    corner.uv = source.cornerUV;\n}\n#endif\n\n// calculate the clip-space offset from the center for this gaussian\nfn initCorner(source: ptr<function, SplatSource>, center: ptr<function, SplatCenter>, corner: ptr<function, SplatCorner>) -> bool {\n    // Get rotation and scale\n    var rotation: vec4f = getRotation().yzwx;  // Convert (w,x,y,z) to (x,y,z,w)\n    var scale: vec3f = getScale();\n\n    // Hook: modify rotation and scale\n    modifySplatRotationScale(center.modelCenterOriginal, center.modelCenterModified, &rotation, &scale);\n\n    #if GSPLAT_2DGS\n        initCorner2DGS(source, rotation, scale, corner);\n        return true;\n    #else\n        // 3DGS: Use covariance-based screen-space projection\n        // Compute covariance from (possibly modified) rotation and scale\n        var covA: vec3f;\n        var covB: vec3f;\n        computeCovariance(rotation.wxyz, scale, &covA, &covB);  // Convert back to (w,x,y,z)\n\n        return initCornerCov(source, center, corner, covA, covB);\n    #endif\n}\n";
export default _default;
