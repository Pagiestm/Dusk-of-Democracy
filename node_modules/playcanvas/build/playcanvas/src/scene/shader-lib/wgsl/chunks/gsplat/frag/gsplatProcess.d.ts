declare const _default: "\n\n// Texture size and splat count uniforms\nuniform splatTextureSize: u32;\nuniform dstTextureSize: u32;\nuniform srcNumSplats: u32;\nuniform dstNumSplats: u32;\n\n// Shared splat identification (index, uv) and setSplat() helper\n#include \"gsplatSplatVS\"\n\n// Input stream declarations (generated by GSplatFormat.getInputDeclarations)\n#include \"gsplatProcessInputVS\"\n\n// Module-scope output for write functions to access\nvar<private> processOutput: FragmentOutput;\n\n// Output write functions (generated by GSplatFormat.getOutputDeclarations)\n#include \"gsplatProcessOutputVS\"\n\n// Format-specific read code (included when \"default\" stream is used)\n#include \"gsplatProcessReadVS\"\n\n// User's process code - defines process() function and any declarations\n#include \"gsplatProcessChunk\"\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    // Fragment coordinates give us the destination splat index\n    let fragCoords = vec2i(input.position.xy);\n    \n    // Linear index of the destination splat\n    let splatIndex = u32(fragCoords.y * i32(uniform.dstTextureSize) + fragCoords.x);\n    \n    // Skip padding pixels (texture may be larger than actual splat count)\n    if (splatIndex >= uniform.dstNumSplats) {\n        discard;\n    }\n    \n    // Initialize global splat for sampling\n    // Note: splat.uv assumes 1:1 mapping using splatTextureSize. When sizes differ,\n    // call setSplat() with a different index in user code.\n    setSplat(splatIndex);\n    \n    // Call user's process function\n    process();\n    \n    return processOutput;\n}\n";
export default _default;
