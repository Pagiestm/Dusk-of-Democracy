declare const _default: "\n#include \"gsplatPackingPS\"\n\n// uniform declarations for dequantization\nuniform means_mins: vec3f;\nuniform means_maxs: vec3f;\n\nuniform scales_mins: f32;\nuniform scales_maxs: f32;\n\n// SH0 color uniforms\nuniform sh0_mins: f32;\nuniform sh0_maxs: f32;\n\n// SH0 texture for color\nvar packedSh0: texture_2d<f32>;\n\n// SH_C0 coefficient for 0th degree spherical harmonic\nconst SH_C0: f32 = 0.28209479177387814;\n\n// work value\nvar<private> packedSample: vec4<u32>;\n\nconst norm: f32 = sqrt(2.0);\n\n// read the model-space center of the gaussian\nfn getCenter() -> vec3f {\n    // read the packed texture sample using generated load function (uses global splat.uv)\n    packedSample = loadPackedTexture();\n\n    let l = unpack8888(packedSample.x).xyz;\n    let u = unpack8888(packedSample.y).xyz;\n    let n = (l + u * 256.0) / 257.0;\n    let v = mix(uniform.means_mins, uniform.means_maxs, n);\n\n    return sign(v) * (exp(abs(v)) - 1.0);\n}\n\nfn getColor() -> vec4f {\n    let clr = mix(vec3f(uniform.sh0_mins), vec3f(uniform.sh0_maxs), unpack111110(pack8888(textureLoad(packedSh0, splat.uv, 0))));\n    let alpha = f32(packedSample.z & 0xffu) / 255.0;\n    return vec4f(vec3f(0.5) + clr * SH_C0, alpha);\n}\n\nfn getRotation() -> vec4f {\n    let qdata = unpack8888(packedSample.z).xyz;\n    let qmode = packedSample.w & 0x3u;\n    let abc = (qdata - 0.5) * norm;\n    let d = sqrt(max(0.0, 1.0 - dot(abc, abc)));\n\n    var quat: vec4f;\n    if (qmode == 0u) {\n        quat = vec4f(d, abc);\n    } else if (qmode == 1u) {\n        quat = vec4f(abc.x, d, abc.y, abc.z);\n    } else if (qmode == 2u) {\n        quat = vec4f(abc.x, abc.y, d, abc.z);\n    } else {\n        quat = vec4f(abc.x, abc.y, abc.z, d);\n    }\n    return quat;\n}\n\nfn getScale() -> vec3f {\n    let sdata = unpack101010(packedSample.w >> 2u);\n    return exp(mix(vec3f(uniform.scales_mins), vec3f(uniform.scales_maxs), sdata));\n}\n\n#include \"gsplatSogSHVS\"\n";
export default _default;
