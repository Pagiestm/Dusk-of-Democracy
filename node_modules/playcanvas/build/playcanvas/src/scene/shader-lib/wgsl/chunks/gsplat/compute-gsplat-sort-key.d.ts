export const computeGsplatSortKeySource: "\n\n// Work buffer texture containing world-space centers (RGBA32U: xyz as floatBitsToUint)\n@group(0) @binding(0) var dataTransformA: texture_2d<u32>;\n\n// Output sort keys (one u32 per splat)\n@group(0) @binding(1) var<storage, read_write> sortKeys: array<u32>;\n\n// Uniforms\nstruct SortKeyUniforms {\n    cameraPosition: vec3f,\n    elementCount: u32,\n    cameraDirection: vec3f,\n    numBits: u32,\n    textureSize: u32,\n    minDist: f32,\n    invRange: f32,\n    numWorkgroupsX: u32,\n    numBins: u32\n};\n@group(0) @binding(2) var<uniform> uniforms: SortKeyUniforms;\n\n// Camera-relative bin weighting (entries with base and divider)\nstruct BinWeight {\n    base: f32,\n    divider: f32\n};\n@group(0) @binding(3) var<storage, read> binWeights: array<BinWeight>;\n\n@compute @workgroup_size({WORKGROUP_SIZE_X}, {WORKGROUP_SIZE_Y}, 1)\nfn computeSortKey(@builtin(global_invocation_id) global_id: vec3u) {\n    let gid = global_id.x + global_id.y * ({WORKGROUP_SIZE_X} * uniforms.numWorkgroupsX);\n    \n    // Early exit for out-of-bounds threads\n    if (gid >= uniforms.elementCount) {\n        return;\n    }\n    \n    // Calculate texture UV from linear index\n    let textureSize = uniforms.textureSize;\n    let uv = vec2i(i32(gid % textureSize), i32(gid / textureSize));\n    \n    // Load world-space center from work buffer (stored as floatBitsToUint)\n    let packed = textureLoad(dataTransformA, uv, 0);\n    let worldCenter = vec3f(\n        bitcast<f32>(packed.r),\n        bitcast<f32>(packed.g),\n        bitcast<f32>(packed.b)\n    );\n    \n    // Calculate distance based on sort mode\n    var dist: f32;\n    \n    #ifdef RADIAL_SORT\n        // Radial mode: distance from camera (inverted so far objects get small keys)\n        let delta = worldCenter - uniforms.cameraPosition;\n        let radialDist = length(delta);\n        // Invert distance so far objects get small keys (rendered first, back-to-front)\n        dist = (1.0 / uniforms.invRange) - radialDist - uniforms.minDist;\n    #else\n        // Linear mode: distance along camera forward vector\n        let toSplat = worldCenter - uniforms.cameraPosition;\n        dist = dot(toSplat, uniforms.cameraDirection) - uniforms.minDist;\n    #endif\n    \n    // Apply bin-based mapping for camera-relative precision weighting\n    let numBins = uniforms.numBins;\n    let d = dist * uniforms.invRange * f32(numBins);\n    let binFloat = clamp(d, 0.0, f32(numBins) - 0.001);\n    let bin = u32(binFloat);\n    let binFrac = binFloat - f32(bin);\n    \n    // Calculate final sort key using pre-computed bin weighting\n    let sortKey = u32(binWeights[bin].base + binWeights[bin].divider * binFrac);\n    \n    // Write sort key\n    sortKeys[gid] = sortKey;\n}\n";
export default computeGsplatSortKeySource;
