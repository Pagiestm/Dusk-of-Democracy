declare const _default: "\n\n#define GSPLAT_CENTER_NOPROJ\n\n#include \"gsplatHelpersVS\"\n#include \"gsplatFormatVS\"\n#include \"gsplatStructsVS\"\n#include \"gsplatDeclarationsVS\"\n#include \"gsplatCenterVS\"\n#include \"gsplatEvalSHVS\"\n#include \"gsplatQuatToMat3VS\"\n#include \"gsplatReadVS\"\n\n// Module-scope output for write functions to access\nvar<private> processOutput: FragmentOutput;\n\n// Work buffer output write functions (generated by GSplatFormat.getOutputDeclarations)\n#include \"gsplatWorkBufferOutputVS\"\n\n#include \"gsplatModifyVS\"\n\nuniform uStartLine: i32;      // Start row in destination texture\nuniform uViewportWidth: i32;  // Width of the destination viewport in pixels\n\n#ifdef GSPLAT_LOD\n    // LOD intervals texture\n    var uIntervalsTexture: texture_2d<u32>;\n#endif\n\nuniform uColorMultiply: vec3f;\n\n// number of splats\nuniform uActiveSplats: i32;\n\n// pre-computed model matrix decomposition\nuniform model_scale: vec3f;\nuniform model_rotation: vec4f;  // (x,y,z,w) format\n\n#ifdef GSPLAT_ID\n    uniform uId: u32;\n#endif\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    // local fragment coordinates (within the viewport)\n    let localFragCoords = vec2i(i32(input.position.x), i32(input.position.y) - uniform.uStartLine);\n\n    // linear index of the splat\n    let targetIndex = localFragCoords.y * uniform.uViewportWidth + localFragCoords.x;\n    \n    if (targetIndex >= uniform.uActiveSplats) {\n\n        // Out of bounds: write zeros using generated write functions\n        writeDataColor(vec4f(0.0));\n        #ifndef GSPLAT_COLOR_ONLY\n            writeDataTransformA(vec4u(0u));\n            writeDataTransformB(vec4u(0u));\n        #endif\n\n    } else {\n\n        #ifdef GSPLAT_LOD\n            // Use intervals texture to remap target index to source index\n            let intervalsSize = i32(textureDimensions(uIntervalsTexture, 0).x);\n            let intervalUV = vec2i(targetIndex % intervalsSize, targetIndex / intervalsSize);\n            let originalIndex = textureLoad(uIntervalsTexture, intervalUV, 0).r;\n        #else\n            let originalIndex = targetIndex;\n        #endif\n        \n        // Initialize global splat for format read functions\n        setSplat(u32(originalIndex));\n\n        // read center in local space\n        var modelCenter = getCenter();\n\n        // compute world-space center for storage\n        var worldCenter = (uniform.matrix_model * vec4f(modelCenter, 1.0)).xyz;\n        var center: SplatCenter;\n        initCenter(modelCenter, &center);\n\n        // Get source rotation and scale\n        // getRotation() returns (w,x,y,z) format, convert to (x,y,z,w) for quatMul\n        let srcRotation = getRotation().yzwx;\n        let srcScale = getScale();\n\n        // Combine: world = model * source (both in x,y,z,w format)\n        var worldRotation = quatMul(uniform.model_rotation, srcRotation);\n        // Ensure w is positive so sqrt() reconstruction works correctly\n        // (quaternions q and -q represent the same rotation)\n        if (worldRotation.w < 0.0) {\n            worldRotation = -worldRotation;\n        }\n        var worldScale = uniform.model_scale * srcScale;\n\n        // Apply custom center modification\n        let originalCenter = worldCenter;\n        modifySplatCenter(&worldCenter);\n\n        // Apply custom rotation/scale modification\n        modifySplatRotationScale(originalCenter, worldCenter, &worldRotation, &worldScale);\n\n        // read color\n        var color = getColor();\n\n        // evaluate spherical harmonics\n        #if SH_BANDS > 0\n            // calculate the model-space view direction\n            let dir = normalize(center.view * mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz));\n\n            // read sh coefficients\n            var sh: array<vec3f, SH_COEFFS>;\n            var scale: f32;\n            readSHData(&sh, &scale);\n\n            // evaluate\n            color = vec4f(color.xyz + evalSH(&sh, dir) * scale, color.w);\n        #endif\n\n        // Apply custom color modification\n        modifySplatColor(worldCenter, &color);\n\n        color = vec4f(color.xyz * uniform.uColorMultiply, color.w);\n\n        // write out results using generated write functions\n        writeDataColor(color);\n        #ifndef GSPLAT_COLOR_ONLY\n            // Store rotation (xyz, w derived) and scale as 6 half-floats\n            writeDataTransformA(vec4u(bitcast<u32>(worldCenter.x), bitcast<u32>(worldCenter.y), bitcast<u32>(worldCenter.z), pack2x16float(worldRotation.xy)));\n            writeDataTransformB(vec4u(pack2x16float(vec2f(worldRotation.z, worldScale.x)), pack2x16float(worldScale.yz), 0u, 0u));\n        #endif\n\n        #ifdef GSPLAT_ID\n            writePcId(vec4u(uniform.uId, 0u, 0u, 0u));\n        #endif\n    }\n    \n    return processOutput;\n}\n";
export default _default;
