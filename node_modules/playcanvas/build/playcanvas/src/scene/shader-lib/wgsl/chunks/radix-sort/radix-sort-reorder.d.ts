declare const _default: "\nvar keysTexture: texture_2d<u32>;\n#ifdef SOURCE_LINEAR\n    #define FIRST_PASS\n#else\n    var indicesTexture: texture_2d<u32>;\n#endif\n\nvar prefixSums: texture_2d<f32>;\n\nuniform bitsPerStep: i32;\nuniform groupSize: i32;\nuniform elementCount: i32;\nuniform imageElementsLog2: i32;\nuniform currentBit: i32;\nuniform imageSize: i32;\n\nvarying uv0: vec2f;\n\n// Morton code functions for Z-order curve indexing\nfn interleaveWithZero(word_in: u32) -> u32 {\n    var word = word_in;\n    word = (word ^ (word << 8u)) & 0x00ff00ffu;\n    word = (word ^ (word << 4u)) & 0x0f0f0f0fu;\n    word = (word ^ (word << 2u)) & 0x33333333u;\n    word = (word ^ (word << 1u)) & 0x55555555u;\n    return word;\n}\n\nfn deinterleaveWithZero(word_in: u32) -> u32 {\n    var word = word_in & 0x55555555u;\n    word = (word | (word >> 1u)) & 0x33333333u;\n    word = (word | (word >> 2u)) & 0x0f0f0f0fu;\n    word = (word | (word >> 4u)) & 0x00ff00ffu;\n    word = (word | (word >> 8u)) & 0x0000ffffu;\n    return word;\n}\n\nfn indexToUV(index: u32) -> vec2i {\n    return vec2i(i32(deinterleaveWithZero(index)), i32(deinterleaveWithZero(index >> 1u)));\n}\n\nfn uvToIndex(uv: vec2i) -> u32 {\n    return interleaveWithZero(u32(uv.x)) | (interleaveWithZero(u32(uv.y)) << 1u);\n}\n\n// Count active texels at a given mip level\n// Uses bit shift instead of pow() for performance\nfn countActiveTexels(uv: vec3i, offset: vec2i) -> f32 {\n    // 4^level = 2^(level*2) = 1 << (level * 2)\n    let scale = f32(1u << (u32(uv.z) * 2u));\n    return scale * textureLoad(prefixSums, uv.xy + offset, uv.z).r;\n}\n\n// Binary search result structure\nstruct BinarySearchResult {\n    pixel: vec2i,\n    prefixSum: f32\n}\n\n// Binary search through the mipmap hierarchy\nfn activeTexelIndexToUV(prefixWidth: f32, index: f32) -> BinarySearchResult {\n    var result: BinarySearchResult;\n    \n    let maxLod = i32(round(log2(prefixWidth)));\n    var uv = vec3i(0, 0, maxLod);\n    \n    let countTotal = countActiveTexels(uv, vec2i(0, 0));\n    result.prefixSum = 0.0;\n    \n    if (index >= countTotal) {\n        result.prefixSum = countTotal;\n        result.pixel = vec2i(-1, -1);\n        return result;\n    }\n    \n    while (uv.z >= 1) {\n        uv = vec3i(uv.xy * 2, uv.z - 1);\n        \n        let count00 = countActiveTexels(uv, vec2i(0, 0));\n        let count01 = countActiveTexels(uv, vec2i(1, 0));\n        let count10 = countActiveTexels(uv, vec2i(0, 1));\n        \n        let in00 = index < (result.prefixSum + count00);\n        let in01 = index < (result.prefixSum + count00 + count01);\n        let in10 = index < (result.prefixSum + count00 + count01 + count10);\n        \n        if (in00) {\n            // Stay at (0,0)\n        } else if (in01) {\n            uv = vec3i(uv.x + 1, uv.y, uv.z);\n            result.prefixSum += count00;\n        } else if (in10) {\n            uv = vec3i(uv.x, uv.y + 1, uv.z);\n            result.prefixSum += count00 + count01;\n        } else {\n            uv = vec3i(uv.x + 1, uv.y + 1, uv.z);\n            result.prefixSum += count00 + count01 + count10;\n        }\n    }\n    \n    result.pixel = uv.xy;\n    return result;\n}\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n    \n    let pixel = vec2i(input.position.xy);\n    \n    #ifdef OUTPUT_LINEAR\n        // Linear index for output (simpler for consumers to read)\n        let index = u32(pixel.y) * u32(uniform.imageSize) + u32(pixel.x);\n    #else\n        // Morton index for internal passes (better cache locality)\n        let index = uvToIndex(pixel);\n    #endif\n    \n    if (index >= u32(uniform.elementCount)) {\n        output.color = vec4u(0xFFFFFFFFu, 0u, 0u, 1u);\n        output.color1 = vec4u(0xFFFFFFFFu, 0u, 0u, 1u);\n        return output;\n    }\n    \n    let prefixWidth = f32(uniform.imageSize * (1i << u32(uniform.bitsPerStep >> 1))) / f32(1i << u32(uniform.groupSize >> 1));\n    let searchResult = activeTexelIndexToUV(prefixWidth, f32(index));\n    \n    if (searchResult.pixel.x < 0) {\n        output.color = vec4u(0xFFFFFFFFu, 0u, 0u, 1u);\n        output.color1 = vec4u(0xFFFFFFFFu, 0u, 0u, 1u);\n        return output;\n    }\n    \n    let activeIndex = uvToIndex(searchResult.pixel);\n    let elementsLog2 = u32(uniform.imageElementsLog2);\n    let groupsLog2 = elementsLog2 - u32(uniform.groupSize);\n    let digitIndex = activeIndex >> groupsLog2;\n    let keyIndex = (activeIndex - (digitIndex << groupsLog2)) << u32(uniform.groupSize);\n    \n    // Linear search within the group - optimized with integer math and incremental coords\n    var outKey: u32 = 0u;\n    let mask = (1u << u32(uniform.bitsPerStep)) - 1u;\n    let localIndexU = u32(f32(index) - searchResult.prefixSum);\n    var localCountU: u32 = 0u;\n    var foundMortonIndex: u32 = keyIndex;\n    \n    #ifdef SOURCE_LINEAR\n        // Compute starting (x,y) once - only 1 div/mod instead of 16\n        let sw = textureDimensions(keysTexture, 0).x;\n        let baseY = keyIndex / sw;\n        let baseX = keyIndex - baseY * sw;\n        var x = baseX;\n        var y = baseY;\n        \n        for (var i: u32 = 0u; i < 16u; i = i + 1u) {\n            let groupPixel = vec2i(i32(x), i32(y));\n            outKey = textureLoad(keysTexture, groupPixel, 0).r;\n            \n            let digit = (outKey >> u32(uniform.currentBit)) & mask;\n            \n            if (digit == digitIndex) {\n                localCountU = localCountU + 1u;\n                if (localCountU > localIndexU) {\n                    foundMortonIndex = keyIndex + i;\n                    break;\n                }\n            }\n            \n            // Advance to next pixel with wrap\n            x = x + 1u;\n            if (x >= sw) {\n                x = 0u;\n                y = y + 1u;\n            }\n        }\n    #else\n        // Morton layout - can't use simple x++ increment, but still use integer math\n        for (var i: u32 = 0u; i < 16u; i = i + 1u) {\n            let mortonIndex = keyIndex + i;\n            let groupPixel = indexToUV(mortonIndex);\n            outKey = textureLoad(keysTexture, groupPixel, 0).r;\n            \n            let digit = (outKey >> u32(uniform.currentBit)) & mask;\n            \n            if (digit == digitIndex) {\n                localCountU = localCountU + 1u;\n                if (localCountU > localIndexU) {\n                    foundMortonIndex = mortonIndex;\n                    break;\n                }\n            }\n        }\n    #endif\n    \n    // Read indices after finding the match\n    #ifdef FIRST_PASS\n        // First pass: indices are implicitly [0,1,2,...], use index directly\n        let outIndex = foundMortonIndex;\n    #else\n        // Subsequent passes: read from shuffled indices texture\n        let indicesPixel = indexToUV(foundMortonIndex);\n        let outIndex = textureLoad(indicesTexture, indicesPixel, 0).r;\n    #endif\n    \n    output.color = vec4u(outKey, 0u, 0u, 1u);\n    output.color1 = vec4u(outIndex, 0u, 0u, 1u);\n    return output;\n}\n";
export default _default;
