declare const _default: "\nattribute particle_vertexData: vec4f;   // XYZ = world pos, W = life\nattribute particle_vertexData2: vec4f;  // X = angle, Y = scale, Z = alpha, W = velocity.x\nattribute particle_vertexData3: vec4f;  // XYZ = particle local pos, W = velocity.y\nattribute particle_vertexData4: f32;    // particle id\n\n// type depends on useMesh property. Start with X = velocity.z, Y = particle ID and for mesh particles proceeds with Z = mesh UV.x, W = mesh UV.y\n#ifndef USE_MESH\n    attribute particle_vertexData5: vec2f;\n#else\n    attribute particle_vertexData5: vec4f;\n#endif\n\nuniform matrix_viewProjection: mat4x4f;\nuniform matrix_model: mat4x4f;\n\n#ifndef VIEWMATRIX\n    #define VIEWMATRIX\n    uniform matrix_view: mat4x4f;\n#endif\n\nuniform matrix_normal: mat3x3f;\nuniform matrix_viewInverse: mat4x4f;\n\nuniform numParticles: f32;\nuniform lifetime: f32;\nuniform stretch: f32;\nuniform seed: f32;\nuniform emitterScale: vec3f;\nuniform faceTangent: vec3f;\nuniform faceBinorm: vec3f;\n\n#ifdef PARTICLE_GPU\n    #ifdef WRAP\n        uniform wrapBounds: vec3f;\n    #endif\n#endif\n\n#ifdef PARTICLE_GPU\n    var internalTex0: texture_2d<uff>;\n    var internalTex1: texture_2d<uff>;\n    var internalTex2: texture_2d<uff>;\n#endif\nuniform emitterPos: vec3f;\n\nvarying texCoordsAlphaLife: vec4f;\n\nstruct RotateResult {\n    rotatedVec: vec2f,\n    matrix: mat2x2f\n}\n\nfn rotateWithMatrix(quadXY: vec2f, pRotation: f32) -> RotateResult {\n    let c = cos(pRotation);\n    let s = sin(pRotation);\n    let m = mat2x2f(vec2f(c, -s), vec2f(s, c));\n    return RotateResult(m * quadXY, m);\n}\n\n\nfn billboard(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {\n    var pos: vec3f;\n    #ifdef SCREEN_SPACE\n        pos = vec3f(-1.0, 0.0, 0.0) * quadXY.x + vec3f(0.0, -1.0, 0.0) * quadXY.y;\n    #else\n        pos = -uniform.matrix_viewInverse[0].xyz * quadXY.x + -uniform.matrix_viewInverse[1].xyz * quadXY.y;\n    #endif\n    return pos;\n}\n\nfn customFace(InstanceCoords: vec3f, quadXY: vec2f) -> vec3f {\n    let pos = uniform.faceTangent * quadXY.x + uniform.faceBinorm * quadXY.y;\n    return pos;\n}\n\nfn safeNormalize(v: vec2f) -> vec2f {\n    let l = length(v);\n    return select(v, v / l, l > 1e-06);\n}\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n\n    var particlePos = input.particle_vertexData.xyz;\n    let inPos = particlePos;\n    let vertPos = input.particle_vertexData3.xyz;\n    var inVel = vec3f(input.particle_vertexData2.w, input.particle_vertexData3.w, input.particle_vertexData5.x);\n\n    let id = floor(input.particle_vertexData4);\n    let rndFactor = fract(sin(id + 1.0 + uniform.seed));\n    let rndFactor3 = vec3f(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\n    #ifdef LOCAL_SPACE\n        let modelRotation = mat3x3f(uniform.matrix_model[0].xyz, uniform.matrix_model[1].xyz, uniform.matrix_model[2].xyz);\n        inVel = modelRotation * inVel;\n    #endif\n    let velocityV = safeNormalize((mat3x3f(uniform.matrix_view[0].xyz, uniform.matrix_view[1].xyz, uniform.matrix_view[2].xyz) * inVel).xy);\n\n    let quadXY = vertPos.xy;\n\n    #ifdef USE_MESH\n        output.texCoordsAlphaLife = vec4f(input.particle_vertexData5.zw, input.particle_vertexData2.z, input.particle_vertexData.w);\n    #else\n        output.texCoordsAlphaLife = vec4f(quadXY * -0.5 + 0.5, input.particle_vertexData2.z, input.particle_vertexData.w);\n    #endif\n    var rotMatrix: mat2x2f;\n\n    var inAngle = input.particle_vertexData2.x;\n    var particlePosMoved = vec3f(0.0);\n    let meshLocalPos = input.particle_vertexData3.xyz;\n";
export default _default;
