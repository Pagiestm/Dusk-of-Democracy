declare const _default: "\n// cached texture fetches\nvar<private> cachedTransformA: vec4u;\nvar<private> cachedTransformB: vec2u;\n\nfn getCenter() -> vec3f {\n    cachedTransformA = loadDataTransformA();\n    cachedTransformB = loadDataTransformB().xy;\n    return vec3f(bitcast<f32>(cachedTransformA.r), bitcast<f32>(cachedTransformA.g), bitcast<f32>(cachedTransformA.b));\n}\n\nfn getColor() -> vec4f {\n    #ifdef GSPLAT_COLOR_FLOAT\n        return loadDataColor();\n    #else\n        // Unpack RGBA from 4x half-float (16-bit) values stored in RGBA16U format\n        let packedColor = loadDataColor();\n        let packed_rg = packedColor.r | (packedColor.g << 16u);\n        let packed_ba = packedColor.b | (packedColor.a << 16u);\n        return vec4f(unpack2x16float(packed_rg), unpack2x16float(packed_ba));\n    #endif\n}\n\nfn getRotation() -> vec4f {\n    let rotXY = unpack2x16float(cachedTransformA.a);\n    let rotZscaleX = unpack2x16float(cachedTransformB.x);\n    let rotXYZ = vec3f(rotXY, rotZscaleX.x);\n    return vec4f(rotXYZ, sqrt(max(0.0, 1.0 - dot(rotXYZ, rotXYZ)))).wxyz;\n}\n\nfn getScale() -> vec3f {\n    let rotZscaleX = unpack2x16float(cachedTransformB.x);\n    let scaleYZ = unpack2x16float(cachedTransformB.y);\n    return vec3f(rotZscaleX.y, scaleYZ);\n}\n";
export default _default;
