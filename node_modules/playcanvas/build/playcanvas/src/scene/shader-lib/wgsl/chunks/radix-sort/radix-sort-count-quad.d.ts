declare const _default: "\n\n// ============================================\n// Quad {i}: Process elements at offset {i} * 4\n// ============================================\n{\n    // Calculate element indices for this quad\n    let base = {i}u * 4u;\n    var mi4 = (keyIndex + base) + QUAD_OFFSETS;\n\n    // Load keys from texture - different coordinate calculation per variant\n    #ifdef SOURCE_LINEAR\n        // Linear layout: convert linear index to 2D coordinates\n        var y4 = vec4i(mi4) / sw;\n        var x4 = vec4i(mi4) - y4 * sw;\n        var keys = vec4u(\n            textureLoad(keysTexture, vec2i(x4.x, y4.x), 0).r,\n            textureLoad(keysTexture, vec2i(x4.y, y4.y), 0).r,\n            textureLoad(keysTexture, vec2i(x4.z, y4.z), 0).r,\n            textureLoad(keysTexture, vec2i(x4.w, y4.w), 0).r\n        );\n    #else\n        // Morton layout: use Z-order curve lookup\n        var keys = vec4u(\n            textureLoad(keysTexture, indexToUV(mi4.x), 0).r,\n            textureLoad(keysTexture, indexToUV(mi4.y), 0).r,\n            textureLoad(keysTexture, indexToUV(mi4.z), 0).r,\n            textureLoad(keysTexture, indexToUV(mi4.w), 0).r\n        );\n    #endif\n\n    // Extract digits and count matches\n    var digits = (keys >> vec4u(cBit)) & mask4;\n    var m4 = select(vec4u(0u), vec4u(1u), digits == digitIdx4);\n\n    // Bounds checking - only included for partial groups (last group)\n    #ifdef BOUNDS_CHECK\n        // Zero out counts for elements past elementCount\n        m4 = select(m4, vec4u(0u), mi4 >= elemCount4);\n    #endif\n\n    // Accumulate count\n    count += m4.x + m4.y + m4.z + m4.w;\n}\n";
export default _default;
