declare const _default: "\n//RG=X, BA=Y\n//RG=Z, BA=A\n//RGB=V, A=visMode\n//RGBA=life\n\nconst PI2: f32 = 6.283185307179586;\n\nuniform inBoundsSize: vec3f;\nuniform inBoundsCenter: vec3f;\n\nuniform maxVel: f32;\n\nfn decodeFloatRG(rg: vec2f) -> f32 {\n    return rg.y * (1.0 / 255.0) + rg.x;\n}\n\nfn decodeFloatRGBA( rgba: vec4f ) -> f32 {\n    return dot(rgba, vec4f(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}\n\nfn readInput(uv: f32) {\n    let textureSize = textureDimensions(particleTexIN, 0);\n    let texel0: vec2i = vec2i(vec2f(uv, 0.125) * vec2f(textureSize));\n    let texel1: vec2i = vec2i(vec2f(uv, 0.375) * vec2f(textureSize));\n    let texel2: vec2i = vec2i(vec2f(uv, 0.625) * vec2f(textureSize));\n    let texel3: vec2i = vec2i(vec2f(uv, 0.875) * vec2f(textureSize));\n    let tex0 = textureLoad(particleTexIN, texel0, 0);\n    let tex1 = textureLoad(particleTexIN, texel1, 0);\n    let tex2 = textureLoad(particleTexIN, texel2, 0);\n    let tex3 = textureLoad(particleTexIN, texel3, 0);\n\n    inPos = vec3f(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n    inPos = (inPos - vec3f(0.5)) * uniform.inBoundsSize + uniform.inBoundsCenter;\n\n    inVel = tex2.xyz;\n    inVel = (inVel - vec3f(0.5)) * uniform.maxVel;\n\n    inAngle = decodeFloatRG(tex1.ba) * PI2;\n    inShow = tex2.a > 0.5;\n\n    let life_decoded = decodeFloatRGBA(tex3);\n    let maxNegLife = max(uniform.lifetime, uniform.numParticles * (uniform.rate + uniform.rateDiv));\n    let maxPosLife = uniform.lifetime + 1.0;\n    inLife = life_decoded * (maxNegLife + maxPosLife) - maxNegLife;\n}";
export default _default;
