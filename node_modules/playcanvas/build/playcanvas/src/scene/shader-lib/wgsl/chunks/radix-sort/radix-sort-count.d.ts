declare const _default: "\nvar keysTexture: texture_2d<u32>;\n\nuniform bitsPerStep: i32;\nuniform groupSize: i32;\nuniform elementCount: i32;\nuniform imageElementsLog2: i32;\nuniform currentBit: i32;\n\nvarying uv0: vec2f;\n\n// Morton code functions for Z-order curve indexing\nfn interleaveWithZero(word_in: u32) -> u32 {\n    var word = word_in;\n    word = (word ^ (word << 8u)) & 0x00ff00ffu;\n    word = (word ^ (word << 4u)) & 0x0f0f0f0fu;\n    word = (word ^ (word << 2u)) & 0x33333333u;\n    word = (word ^ (word << 1u)) & 0x55555555u;\n    return word;\n}\n\nfn deinterleaveWithZero(word_in: u32) -> u32 {\n    var word = word_in & 0x55555555u;\n    word = (word | (word >> 1u)) & 0x33333333u;\n    word = (word | (word >> 2u)) & 0x0f0f0f0fu;\n    word = (word | (word >> 4u)) & 0x00ff00ffu;\n    word = (word | (word >> 8u)) & 0x0000ffffu;\n    return word;\n}\n\nfn indexToUV(index: u32) -> vec2i {\n    return vec2i(i32(deinterleaveWithZero(index)), i32(deinterleaveWithZero(index >> 1u)));\n}\n\nfn uvToIndex(uv: vec2i) -> u32 {\n    return interleaveWithZero(u32(uv.x)) | (interleaveWithZero(u32(uv.y)) << 1u);\n}\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n    \n    // Get current pixel position\n    let pixel = vec2i(input.position.xy);\n    let morton = uvToIndex(pixel);\n    \n    // Calculate which digit and which group this pixel represents\n    let elementsLog2 = u32(uniform.imageElementsLog2);\n    let groupsLog2 = elementsLog2 - u32(uniform.groupSize);\n    let digitIndex = morton >> groupsLog2;\n    let keyIndex = (morton - (digitIndex << groupsLog2)) << u32(uniform.groupSize);\n    let elemCount = u32(uniform.elementCount);\n    \n    // Out of bounds check - this group starts past valid data\n    if (keyIndex >= elemCount) {\n        output.color = 0.0;\n        return output;\n    }\n    \n    // Setup variables for quad processing\n    var count: u32 = 0u;\n    let mask = (1u << u32(uniform.bitsPerStep)) - 1u;\n    let cBit = u32(uniform.currentBit);\n    let digitIdx4 = vec4u(digitIndex);\n    let mask4 = vec4u(mask);\n    let elemCount4 = vec4u(elemCount);\n    let QUAD_OFFSETS = vec4u(0u, 1u, 2u, 3u);\n    \n    // Check if this is a partial group (last group that extends past elementCount)\n    let isPartialGroup = (keyIndex + 16u) > elemCount;\n    \n    #ifdef SOURCE_LINEAR\n        let sw = i32(textureDimensions(keysTexture, 0).x);\n    #endif\n    \n    // Process all 4 quads (16 elements total per group)\n    // Use define/undef to control bounds checking at compile time\n    #define QUAD_COUNT 4\n    if (isPartialGroup) {\n        // Partial group: include bounds checking\n        #define BOUNDS_CHECK\n        #include \"radixSortCountQuad, QUAD_COUNT\"\n        #undef BOUNDS_CHECK\n    } else {\n        // Full group: no bounds checking needed (fast path)\n        #include \"radixSortCountQuad, QUAD_COUNT\"\n    }\n    \n    // Output the count as raw float (R32F format)\n    output.color = f32(count);\n    return output;\n}\n";
export default _default;
