export const radixSort4bitSource: "\n\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> local_prefix_sums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> block_sums: array<u32>;\n\n// Uniforms (values that change per-sort)\nstruct RadixSortUniforms {\n    workgroupCount: u32,\n    elementCount: u32\n};\n@group(0) @binding(3) var<uniform> uniforms: RadixSortUniforms;\n\n// Compile-time constants\nconst THREADS_PER_WORKGROUP: u32 = {THREADS_PER_WORKGROUP}u;\nconst WORKGROUP_SIZE_X: u32 = {WORKGROUP_SIZE_X}u;\nconst WORKGROUP_SIZE_Y: u32 = {WORKGROUP_SIZE_Y}u;\nconst CURRENT_BIT: u32 = {CURRENT_BIT}u;\n\n// Shared memory\nvar<workgroup> histogram: array<atomic<u32>, 16>;\nvar<workgroup> thread_digits: array<u32, 256>;  // Store each thread's digit\n\n@compute @workgroup_size(WORKGROUP_SIZE_X, WORKGROUP_SIZE_Y, 1)\nfn radix_sort(\n    @builtin(workgroup_id) w_id: vec3<u32>,\n    @builtin(num_workgroups) w_dim: vec3<u32>,\n    @builtin(local_invocation_index) TID: u32,\n) {\n    let WORKGROUP_ID = w_id.x + w_id.y * w_dim.x;\n    let WID = WORKGROUP_ID * THREADS_PER_WORKGROUP;\n    let GID = WID + TID;\n\n    // Initialize histogram (first 16 threads)\n    if (TID < 16u) {\n        atomicStore(&histogram[TID], 0u);\n    }\n    workgroupBarrier();\n\n    // Extract 4 bits from the input (0-15), use 16 as invalid marker\n    let is_valid = GID < uniforms.elementCount && WORKGROUP_ID < uniforms.workgroupCount;\n    let elm = select(0u, input[GID], is_valid);\n    let digit: u32 = select(16u, (elm >> CURRENT_BIT) & 0xFu, is_valid);\n\n    // Store digit in shared memory for other threads to read\n    thread_digits[TID] = digit;\n\n    // Build histogram using atomics (fast)\n    if (is_valid) {\n        atomicAdd(&histogram[digit], 1u);\n    }\n    workgroupBarrier();\n\n    // Count threads with same digit and lower TID (maintains stability)\n    // Vectorized: check 4 threads at a time\n    var local_prefix: u32 = 0u;\n    if (is_valid) {\n        let digit_vec = vec4<u32>(digit, digit, digit, digit);\n        let ones = vec4<u32>(1u, 1u, 1u, 1u);\n        let zeros = vec4<u32>(0u, 0u, 0u, 0u);\n        \n        // Main loop: process 4 threads at a time\n        var i: u32 = 0u;\n        let limit = TID & ~3u;  // Round down to multiple of 4\n        for (; i < limit; i += 4u) {\n            let d = vec4<u32>(\n                thread_digits[i],\n                thread_digits[i + 1u],\n                thread_digits[i + 2u],\n                thread_digits[i + 3u]\n            );\n            let matches = select(zeros, ones, d == digit_vec);\n            local_prefix += matches.x + matches.y + matches.z + matches.w;\n        }\n        \n        // Handle remainder (0-3 elements)\n        for (; i < TID; i++) {\n            local_prefix += select(0u, 1u, thread_digits[i] == digit);\n        }\n    }\n\n    // Write results\n    if (is_valid) {\n        local_prefix_sums[GID] = local_prefix;\n    }\n\n    // Store block sums (histogram values) to global memory\n    if (TID < 16u && WORKGROUP_ID < uniforms.workgroupCount) {\n        block_sums[TID * uniforms.workgroupCount + WORKGROUP_ID] = atomicLoad(&histogram[TID]);\n    }\n}\n";
export default radixSort4bitSource;
