declare const _default: "\n#include \"gsplatCommonVS\"\n\nvarying gaussianUV: vec2f;\nvarying gaussianColor: vec4f;\n\n#ifndef DITHER_NONE\n    varying id: f32;\n#endif\n\nconst discardVec: vec4f = vec4f(0.0, 0.0, 2.0, 1.0);\n\n#ifdef PREPASS_PASS\n    varying vLinearDepth: f32;\n#endif\n\n#if defined(GSPLAT_UNIFIED_ID) && defined(PICK_PASS)\n    varying @interpolate(flat) vPickId: u32;\n#endif\n\n#ifdef GSPLAT_OVERDRAW\n    uniform colorRampIntensity: f32;\n    var colorRamp: texture_2d<f32>;\n    var colorRampSampler: sampler;\n#endif\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n    var output: VertexOutput;\n\n    // read gaussian details\n    var source: SplatSource;\n    if (!initSource(&source)) {\n        output.position = discardVec;\n        return output;\n    }\n\n    var modelCenter: vec3f = getCenter();\n\n    var center: SplatCenter;\n    center.modelCenterOriginal = modelCenter;\n    \n    modifySplatCenter(&modelCenter);\n    center.modelCenterModified = modelCenter;\n\n    if (!initCenter(modelCenter, &center)) {\n        output.position = discardVec;\n        return output;\n    }\n\n    // project center to screen space\n    var corner: SplatCorner;\n    if (!initCorner(&source, &center, &corner)) {\n        output.position = discardVec;\n        return output;\n    }\n\n    // read color\n    var clr: vec4f = getColor();\n\n    #if GSPLAT_AA\n        // apply AA compensation\n        clr.a = clr.a * corner.aaFactor;\n    #endif\n\n    // evaluate spherical harmonics\n    #if SH_BANDS > 0\n        // calculate the model-space view direction\n        let modelView3x3 = mat3x3f(center.modelView[0].xyz, center.modelView[1].xyz, center.modelView[2].xyz);\n        let dir = normalize(center.view * modelView3x3);\n\n        // read sh coefficients\n        var sh: array<vec3f, SH_COEFFS>;\n        var scale: f32;\n        readSHData(&sh, &scale);\n\n        // evaluate\n        clr = vec4f(clr.xyz + evalSH(&sh, dir) * scale, clr.a);\n    #endif\n\n    modifySplatColor(modelCenter, &clr);\n\n    clipCorner(&corner, clr.w);\n\n    // write output\n    #if GSPLAT_2DGS\n        // 2DGS: Project world corner directly\n        let modelCorner: vec3f = center.modelCenterModified + corner.offset;\n        output.position = uniform.matrix_projection * center.modelView * vec4f(modelCorner, 1.0);\n    #else\n        // 3DGS: Add clip-space offset to projected center\n        output.position = center.proj + vec4f(corner.offset.xyz, 0.0);\n    #endif\n    output.gaussianUV = corner.uv;\n\n    #ifdef GSPLAT_OVERDRAW\n        // Overdraw visualization mode: color by elevation\n        let t: f32 = clamp(originalCenter.y / 20.0, 0.0, 1.0);\n        let rampColor: vec3f = textureSampleLevel(colorRamp, colorRampSampler, vec2f(t, 0.5), 0.0).rgb;\n        clr.a = clr.a * (1.0 / 32.0) * uniform.colorRampIntensity;\n        output.gaussianColor = vec4f(rampColor, clr.a);\n    #else\n        output.gaussianColor = vec4f(prepareOutputFromGamma(max(clr.xyz, vec3f(0.0))), clr.w);\n    #endif\n\n    #ifndef DITHER_NONE\n        output.id = f32(splat.index);\n    #endif\n\n    #ifdef PREPASS_PASS\n        output.vLinearDepth = -center.view.z;\n    #endif\n\n    #if defined(GSPLAT_UNIFIED_ID) && defined(PICK_PASS)\n        output.vPickId = loadPcId().r;\n    #endif\n\n    return output;\n}\n";
export default _default;
