import { Vec3 } from '../../core/math/vec3.js';
import { Quat } from '../../core/math/quat.js';
import { TransformGizmo } from './transform-gizmo.js';
import { PlaneShape } from './shape/plane-shape.js';
import { ArrowShape } from './shape/arrow-shape.js';
import { SphereShape } from './shape/sphere-shape.js';

const v1 = new Vec3();
const v2 = new Vec3();
const point = new Vec3();
const delta = new Vec3();
const q = new Quat();
const GLANCE_EPSILON = 0.01;
const AXES = [
		'x',
		'y',
		'z'
];
class TranslateGizmo extends TransformGizmo {
		set axisGap(value) {
				this._setArrowProp('gap', value);
		}
		get axisGap() {
				return this._shapes.x.gap;
		}
		set axisLineThickness(value) {
				this._setArrowProp('lineThickness', value);
		}
		get axisLineThickness() {
				return this._shapes.x.lineThickness;
		}
		set axisLineLength(value) {
				this._setArrowProp('lineLength', value);
		}
		get axisLineLength() {
				return this._shapes.x.lineLength;
		}
		set axisLineTolerance(value) {
				this._setArrowProp('tolerance', value);
		}
		get axisLineTolerance() {
				return this._shapes.x.tolerance;
		}
		set axisArrowThickness(value) {
				this._setArrowProp('arrowThickness', value);
		}
		get axisArrowThickness() {
				return this._shapes.x.arrowThickness;
		}
		set axisArrowLength(value) {
				this._setArrowProp('arrowLength', value);
		}
		get axisArrowLength() {
				return this._shapes.x.arrowLength;
		}
		set axisPlaneSize(value) {
				this._setPlaneProp('size', value);
		}
		get axisPlaneSize() {
				return this._shapes.yz.size;
		}
		set axisPlaneGap(value) {
				this._setPlaneProp('gap', value);
		}
		get axisPlaneGap() {
				return this._shapes.yz.gap;
		}
		set axisCenterSize(value) {
				this._shapes.xyz.radius = value;
		}
		get axisCenterSize() {
				return this._shapes.xyz.radius;
		}
		set flipShapes(value) {
				this.flipPlanes = value;
		}
		get flipShapes() {
				return this.flipPlanes;
		}
		_setArrowProp(prop, value) {
				this._shapes.x[prop] = value;
				this._shapes.y[prop] = value;
				this._shapes.z[prop] = value;
		}
		_setPlaneProp(prop, value) {
				this._shapes.yz[prop] = value;
				this._shapes.xz[prop] = value;
				this._shapes.xy[prop] = value;
		}
		_shapesLookAtCamera() {
				const cameraDir = this.cameraDir;
				let changed = false;
				let dot, enabled;
				dot = cameraDir.dot(this.root.right);
				enabled = 1 - Math.abs(dot) > GLANCE_EPSILON;
				if (this._shapes.x.entity.enabled !== enabled) {
						this._shapes.x.entity.enabled = enabled;
						changed = true;
				}
				dot = cameraDir.dot(this.root.up);
				enabled = 1 - Math.abs(dot) > GLANCE_EPSILON;
				if (this._shapes.y.entity.enabled !== enabled) {
						this._shapes.y.entity.enabled = enabled;
						changed = true;
				}
				dot = cameraDir.dot(this.root.forward);
				enabled = 1 - Math.abs(dot) > GLANCE_EPSILON;
				if (this._shapes.z.entity.enabled !== enabled) {
						this._shapes.z.entity.enabled = enabled;
						changed = true;
				}
				let flipped;
				v1.cross(cameraDir, this.root.right);
				enabled = 1 - v1.length() > GLANCE_EPSILON;
				if (this._shapes.yz.entity.enabled !== enabled) {
						this._shapes.yz.entity.enabled = enabled;
						changed = true;
				}
				flipped = this.flipPlanes ? v2.set(0, +(v1.dot(this.root.forward) < 0), +(v1.dot(this.root.up) < 0)) : Vec3.ZERO;
				if (!this._shapes.yz.flipped.equals(flipped)) {
						this._shapes.yz.flipped = flipped;
						changed = true;
				}
				v1.cross(cameraDir, this.root.forward);
				enabled = 1 - v1.length() > GLANCE_EPSILON;
				if (this._shapes.xy.entity.enabled !== enabled) {
						this._shapes.xy.entity.enabled = enabled;
						changed = true;
				}
				flipped = this.flipPlanes ? v2.set(+(v1.dot(this.root.up) < 0), +(v1.dot(this.root.right) > 0), 0) : Vec3.ZERO;
				if (!this._shapes.xy.flipped.equals(flipped)) {
						this._shapes.xy.flipped = flipped;
						changed = true;
				}
				v1.cross(cameraDir, this.root.up);
				enabled = 1 - v1.length() > GLANCE_EPSILON;
				if (this._shapes.xz.entity.enabled !== enabled) {
						this._shapes.xz.entity.enabled = enabled;
						changed = true;
				}
				flipped = this.flipPlanes ? v2.set(+(v1.dot(this.root.forward) > 0), 0, +(v1.dot(this.root.right) > 0)) : Vec3.ZERO;
				if (!this._shapes.xz.flipped.equals(flipped)) {
						this._shapes.xz.flipped = flipped;
						changed = true;
				}
				if (changed) {
						this._renderUpdate = true;
				}
		}
		_drag(state) {
				for(const axis in this._shapes){
						const shape = this._shapes[axis];
						switch(this.dragMode){
								case 'show':
										{
												continue;
										}
								case 'hide':
										{
												shape.visible = !state;
												continue;
										}
								case 'selected':
										{
												if (this._selectedAxis === 'xyz') {
														shape.visible = state ? axis.length === 1 : true;
														continue;
												}
												if (this._selectedIsPlane) {
														shape.visible = state ? axis.length === 1 && !axis.includes(this._selectedAxis) : true;
														continue;
												}
												shape.visible = state ? axis === this._selectedAxis : true;
										}
						}
				}
				this._renderUpdate = true;
		}
		_storeNodePositions() {
				for(let i = 0; i < this.nodes.length; i++){
						const node = this.nodes[i];
						this._nodeLocalPositions.set(node, node.getLocalPosition().clone());
						this._nodePositions.set(node, node.getPosition().clone());
				}
		}
		_setNodePositions(translateDelta) {
				for(let i = 0; i < this.nodes.length; i++){
						const node = this.nodes[i];
						if (this._coordSpace === 'local') {
								const pos = this._nodeLocalPositions.get(node);
								if (!pos) {
										continue;
								}
								v1.copy(translateDelta);
								node.parent?.getWorldTransform().getScale(v2);
								v2.x = 1 / v2.x;
								v2.y = 1 / v2.y;
								v2.z = 1 / v2.z;
								q.copy(node.getLocalRotation()).transformVector(v1, v1);
								v1.mul(v2);
								node.setLocalPosition(v1.add(pos));
						} else {
								const pos = this._nodePositions.get(node);
								if (!pos) {
										continue;
								}
								node.setPosition(v1.copy(translateDelta).add(pos));
						}
				}
				this._updatePosition();
		}
		_screenToPoint(x, y) {
				const mouseWPos = this._camera.screenToWorld(x, y, 1);
				const axis = this._selectedAxis;
				const isPlane = this._selectedIsPlane;
				const ray = this._createRay(mouseWPos);
				const plane = this._createPlane(axis, axis === 'xyz', !isPlane);
				if (!plane.intersectsRay(ray, point)) {
						return point;
				}
				q.copy(this._rootStartRot).invert().transformVector(point, point);
				if (!isPlane && axis !== 'xyz') {
						this._projectToAxis(point, axis);
				}
				return point;
		}
		_drawGuideLines(pos, rot, activeAxis, activeIsPlane) {
				for (const axis of AXES){
						if (this._dragging || activeAxis === 'xyz') {
								this._drawSpanLine(pos, rot, axis);
								continue;
						}
						if (activeIsPlane) {
								if (axis !== activeAxis) {
										this._drawSpanLine(pos, rot, axis);
								}
						} else {
								if (axis === activeAxis) {
										this._drawSpanLine(pos, rot, axis);
								}
						}
				}
		}
		prerender() {
				super.prerender();
				if (!this.enabled) {
						return;
				}
				this._shapesLookAtCamera();
		}
		constructor(camera, layer){
				super(camera, layer, 'gizmo:translate'), this._shapes = {
						xyz: new SphereShape(this._device, {
								axis: 'xyz',
								layers: [
										this._layer.id
								],
								defaultColor: this._theme.shapeBase.xyz,
								hoverColor: this._theme.shapeHover.xyz,
								disabledColor: this._theme.disabled
						}),
						yz: new PlaneShape(this._device, {
								axis: 'x',
								layers: [
										this._layer.id
								],
								rotation: new Vec3(0, 0, -90),
								defaultColor: this._theme.shapeBase.x,
								hoverColor: this._theme.shapeHover.x,
								disabledColor: this._theme.disabled,
								depth: 1
						}),
						xz: new PlaneShape(this._device, {
								axis: 'y',
								layers: [
										this._layer.id
								],
								rotation: new Vec3(0, 0, 0),
								defaultColor: this._theme.shapeBase.y,
								hoverColor: this._theme.shapeHover.y,
								disabledColor: this._theme.disabled,
								depth: 1
						}),
						xy: new PlaneShape(this._device, {
								axis: 'z',
								layers: [
										this._layer.id
								],
								rotation: new Vec3(90, 0, 0),
								defaultColor: this._theme.shapeBase.z,
								hoverColor: this._theme.shapeHover.z,
								disabledColor: this._theme.disabled,
								depth: 1
						}),
						x: new ArrowShape(this._device, {
								axis: 'x',
								layers: [
										this._layer.id
								],
								rotation: new Vec3(0, 0, -90),
								defaultColor: this._theme.shapeBase.x,
								hoverColor: this._theme.shapeHover.x,
								disabledColor: this._theme.disabled
						}),
						y: new ArrowShape(this._device, {
								axis: 'y',
								layers: [
										this._layer.id
								],
								rotation: new Vec3(0, 0, 0),
								defaultColor: this._theme.shapeBase.y,
								hoverColor: this._theme.shapeHover.y,
								disabledColor: this._theme.disabled
						}),
						z: new ArrowShape(this._device, {
								axis: 'z',
								layers: [
										this._layer.id
								],
								rotation: new Vec3(90, 0, 0),
								defaultColor: this._theme.shapeBase.z,
								hoverColor: this._theme.shapeHover.z,
								disabledColor: this._theme.disabled
						})
				}, this._nodeLocalPositions = new Map(), this._nodePositions = new Map(), this.snapIncrement = 1, this.flipPlanes = true;
				this._createTransform();
				this.on(TransformGizmo.EVENT_TRANSFORMSTART, ()=>{
						this._storeNodePositions();
						this._drag(true);
				});
				this.on(TransformGizmo.EVENT_TRANSFORMMOVE, (point)=>{
						const translateDelta = delta.copy(point).sub(this._selectionStartPoint);
						if (this.snap) {
								translateDelta.mulScalar(1 / this.snapIncrement);
								translateDelta.round();
								translateDelta.mulScalar(this.snapIncrement);
						}
						this._setNodePositions(translateDelta);
				});
				this.on(TransformGizmo.EVENT_TRANSFORMEND, ()=>{
						this._drag(false);
				});
				this.on(TransformGizmo.EVENT_NODESDETACH, ()=>{
						this._nodeLocalPositions.clear();
						this._nodePositions.clear();
				});
		}
}

export { TranslateGizmo };
