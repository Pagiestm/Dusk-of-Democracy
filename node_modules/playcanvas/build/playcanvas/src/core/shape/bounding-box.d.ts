/**
 * Axis-Aligned Bounding Box. An AABB is commonly used for fast overlap tests in collision
 * detection, spatial indexing and frustum culling.
 *
 * @category Math
 */
export class BoundingBox {
    /**
     * Compute the min and max bounding values to encapsulate all specified vertices.
     *
     * @param {number[]|Float32Array} vertices - The vertices used to compute the new size for the
     * AABB.
     * @param {Vec3} min - Stored computed min value.
     * @param {Vec3} max - Stored computed max value.
     * @param {number} [numVerts] - Number of vertices to use from the beginning of vertices array.
     * All vertices are used if not specified.
     */
    static computeMinMax(vertices: number[] | Float32Array, min: Vec3, max: Vec3, numVerts?: number): void;
    /**
     * Create a new BoundingBox instance. The bounding box is axis-aligned.
     *
     * @param {Vec3} [center] - Center of box. The constructor copies this parameter. Defaults to
     * (0, 0, 0).
     * @param {Vec3} [halfExtents] - Half the distance across the box in each axis. The constructor
     * copies this parameter. Defaults to (0.5, 0.5, 0.5).
     */
    constructor(center?: Vec3, halfExtents?: Vec3);
    /**
     * Center of box.
     *
     * @type {Vec3}
     * @readonly
     */
    readonly center: Vec3;
    /**
     * Half the distance across the box in each axis.
     *
     * @type {Vec3}
     * @readonly
     */
    readonly halfExtents: Vec3;
    /**
     * @type {Vec3}
     * @private
     */
    private _min;
    /**
     * @type {Vec3}
     * @private
     */
    private _max;
    /**
     * Combines two bounding boxes into one, enclosing both.
     *
     * @param {BoundingBox} other - Bounding box to add.
     */
    add(other: BoundingBox): void;
    /**
     * Copies the contents of a source AABB.
     *
     * @param {BoundingBox} src - The AABB to copy from.
     */
    copy(src: BoundingBox): void;
    /**
     * Returns a clone of the AABB.
     *
     * @returns {BoundingBox} A duplicate AABB.
     */
    clone(): BoundingBox;
    /**
     * Test whether two axis-aligned bounding boxes intersect.
     *
     * @param {BoundingBox} other - Bounding box to test against.
     * @returns {boolean} True if there is an intersection.
     */
    intersects(other: BoundingBox): boolean;
    _intersectsRay(ray: any, point: any): boolean;
    _fastIntersectsRay(ray: any): boolean;
    /**
     * Test if a ray intersects with the AABB.
     *
     * @param {Ray} ray - Ray to test against (direction must be normalized).
     * @param {Vec3} [point] - If there is an intersection, the intersection point will be copied
     * into here.
     * @returns {boolean} True if there is an intersection.
     */
    intersectsRay(ray: Ray, point?: Vec3): boolean;
    /**
     * Sets the minimum and maximum corner of the AABB. Using this function is faster than
     * assigning min and max separately.
     *
     * @param {Vec3} min - The minimum corner of the AABB.
     * @param {Vec3} max - The maximum corner of the AABB.
     */
    setMinMax(min: Vec3, max: Vec3): void;
    /**
     * Return the minimum corner of the AABB.
     *
     * @returns {Vec3} Minimum corner.
     */
    getMin(): Vec3;
    /**
     * Return the maximum corner of the AABB.
     *
     * @returns {Vec3} Maximum corner.
     */
    getMax(): Vec3;
    /**
     * Test if a point is inside an AABB.
     *
     * @param {Vec3} point - Point to test.
     * @returns {boolean} True if the point is inside the AABB and false otherwise.
     */
    containsPoint(point: Vec3): boolean;
    /**
     * Return the point on the AABB closest to a given point. If the point is inside the AABB, the
     * point itself is returned.
     *
     * @param {Vec3} point - Point to find the closest point to.
     * @param {Vec3} [result] - The vector to store the result in. If not provided, a new Vec3 is
     * created and returned.
     * @returns {Vec3} The closest point on the AABB.
     * @example
     * const box = new BoundingBox(new Vec3(0, 0, 0), new Vec3(1, 1, 1));
     * const point = new Vec3(2, 0, 0);
     * const closest = box.closestPoint(point); // Returns Vec3(1, 0, 0)
     * @example
     * // Reuse a result vector to avoid allocations in hot paths
     * const result = new Vec3();
     * box.closestPoint(point, result);
     */
    closestPoint(point: Vec3, result?: Vec3): Vec3;
    /**
     * Set an AABB to enclose the specified AABB if it were to be transformed by the specified 4x4
     * matrix.
     *
     * @param {BoundingBox} aabb - Box to transform and enclose.
     * @param {Mat4} m - Transformation matrix to apply to source AABB.
     * @param {boolean} ignoreScale - If true is specified, a scale from the matrix is ignored. Defaults to false.
     */
    setFromTransformedAabb(aabb: BoundingBox, m: Mat4, ignoreScale?: boolean): void;
    /**
     * Compute the size of the AABB to encapsulate all specified vertices.
     *
     * @param {number[]|Float32Array} vertices - The vertices used to compute the new size for the
     * AABB.
     * @param {number} [numVerts] - Number of vertices to use from the beginning of vertices array.
     * All vertices are used if not specified.
     */
    compute(vertices: number[] | Float32Array, numVerts?: number): void;
    /**
     * Test if a Bounding Sphere is overlapping, enveloping, or inside this AABB.
     *
     * @param {BoundingSphere} sphere - Bounding Sphere to test.
     * @returns {boolean} True if the Bounding Sphere is overlapping, enveloping, or inside the
     * AABB and false otherwise.
     */
    intersectsBoundingSphere(sphere: BoundingSphere): boolean;
    _distanceToBoundingSphereSq(sphere: any): number;
    _expand(expandMin: any, expandMax: any): void;
}
import { Vec3 } from '../math/vec3.js';
import type { Ray } from './ray.js';
import type { Mat4 } from '../math/mat4.js';
import type { BoundingSphere } from './bounding-sphere.js';
