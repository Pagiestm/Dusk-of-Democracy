import { BlendState } from '../../platform/graphics/blend-state.js';
import { RenderPass } from '../../platform/graphics/render-pass.js';
import { SHADER_DEPTH_PICK, SHADER_PICK } from '../../scene/constants.js';

const tempMeshInstances = [];
const lights = [
		[],
		[],
		[]
];
const defaultShadowAtlasParams = new Float32Array(2);
class RenderPassPicker extends RenderPass {
		destroy() {
				this.viewBindGroups.forEach((bg)=>{
						bg.defaultUniformBuffer.destroy();
						bg.destroy();
				});
				this.viewBindGroups.length = 0;
		}
		update(camera, scene, layers, mapping, depth) {
				this.camera = camera;
				this.scene = scene;
				this.layers = layers;
				this.mapping = mapping;
				this.depth = depth;
				if (scene.clusteredLightingEnabled) {
						this.emptyWorldClusters = this.renderer.worldClustersAllocator.empty;
				}
		}
		execute() {
				const device = this.device;
				const { renderer, camera, scene, layers, mapping, renderTarget } = this;
				const srcLayers = scene.layers.layerList;
				const subLayerEnabled = scene.layers.subLayerEnabled;
				const isTransparent = scene.layers.subLayerList;
				for(let i = 0; i < srcLayers.length; i++){
						const srcLayer = srcLayers[i];
						if (layers && layers.indexOf(srcLayer) < 0) {
								continue;
						}
						if (srcLayer.enabled && subLayerEnabled[i]) {
								if (srcLayer.camerasSet.has(camera.camera)) {
										const transparent = isTransparent[i];
										if (srcLayer._clearDepthBuffer) {
												renderer.clear(camera.camera, false, true, false);
										}
										const meshInstances = srcLayer.meshInstances;
										for(let j = 0; j < meshInstances.length; j++){
												const meshInstance = meshInstances[j];
												if (meshInstance.pick && meshInstance.transparent === transparent) {
														tempMeshInstances.push(meshInstance);
														mapping.set(meshInstance.id, meshInstance);
												}
										}
										if (scene.gsplat.enableIds) {
												const placements = srcLayer.gsplatPlacements;
												for(let j = 0; j < placements.length; j++){
														const placement = placements[j];
														const component = placement.node?.gsplat;
														if (component) {
																mapping.set(placement.id, component);
														}
												}
										}
										if (tempMeshInstances.length > 0) {
												const clusteredLightingEnabled = scene.clusteredLightingEnabled;
												if (clusteredLightingEnabled) {
														const lightClusters = this.emptyWorldClusters;
														lightClusters.activate();
												}
												renderer.setCameraUniforms(camera.camera, renderTarget);
												renderer.dispatchGlobalLights(scene);
												device.scope.resolve('shadowAtlasParams').setValue(defaultShadowAtlasParams);
												if (device.supportsUniformBuffers) {
														renderer.initViewBindGroupFormat(clusteredLightingEnabled);
														renderer.setupViewUniformBuffers(this.viewBindGroups, renderer.viewUniformFormat, renderer.viewBindGroupFormat, null);
												}
												const shaderPass = this.depth ? SHADER_DEPTH_PICK : SHADER_PICK;
												renderer.renderForward(camera.camera, renderTarget, tempMeshInstances, lights, shaderPass, (meshInstance)=>{
														device.setBlendState(this.blendState);
												});
												tempMeshInstances.length = 0;
										}
								}
						}
				}
		}
		constructor(device, renderer){
				super(device), this.viewBindGroups = [], this.blendState = BlendState.NOBLEND;
				this.renderer = renderer;
		}
}

export { RenderPassPicker };
