/**
 * A representation of a compute shader with the associated resources, that can be executed on the
 * GPU. Only supported on WebGPU platform.
 */
export class Compute {
    /**
     * Create a compute instance. Note that this is supported on WebGPU only and is a no-op on
     * other platforms.
     *
     * @param {GraphicsDevice} graphicsDevice -
     * The graphics device.
     * @param {Shader} shader - The compute shader.
     * @param {string} [name] - The name of the compute instance, used for debugging only.
     */
    constructor(graphicsDevice: GraphicsDevice, shader: Shader, name?: string);
    /**
     * A compute shader.
     *
     * @type {Shader|null}
     * @ignore
     */
    shader: Shader | null;
    /**
     * The non-unique name of an instance of the class. Defaults to 'Unnamed'.
     *
     * @type {string}
     */
    name: string;
    /**
     * @type {Map<string, ComputeParameter>}
     * @ignore
     */
    parameters: Map<string, ComputeParameter>;
    /**
     * @type {number}
     * @ignore
     */
    countX: number;
    /**
     * @type {number|undefined}
     * @ignore
     */
    countY: number | undefined;
    /**
     * @type {number|undefined}
     * @ignore
     */
    countZ: number | undefined;
    /**
     * Slot index in the indirect dispatch buffer, or -1 for direct dispatch.
     *
     * @type {number}
     * @ignore
     */
    indirectSlotIndex: number;
    /**
     * Custom buffer for indirect dispatch, or null to use device's built-in buffer.
     *
     * @type {StorageBuffer|null}
     * @ignore
     */
    indirectBuffer: StorageBuffer | null;
    /**
     * Frame stamp (device.renderVersion) when indirect slot was set. Used for validation
     * when using the built-in buffer.
     *
     * @type {number}
     * @ignore
     */
    indirectFrameStamp: number;
    device: GraphicsDevice;
    impl: any;
    /**
     * Sets a shader parameter on a compute instance.
     *
     * @param {string} name - The name of the parameter to set.
     * @param {number|number[]|Float32Array|Texture|StorageBuffer|VertexBuffer|IndexBuffer|TextureView} value -
     * The value for the specified parameter.
     */
    setParameter(name: string, value: number | number[] | Float32Array | Texture | StorageBuffer | VertexBuffer | IndexBuffer | TextureView): void;
    /**
     * Returns the value of a shader parameter from the compute instance.
     *
     * @param {string} name - The name of the parameter to get.
     * @returns {number|number[]|Float32Array|Texture|StorageBuffer|VertexBuffer|IndexBuffer|undefined}
     * The value of the specified parameter.
     */
    getParameter(name: string): number | number[] | Float32Array | Texture | StorageBuffer | VertexBuffer | IndexBuffer | undefined;
    /**
     * Deletes a shader parameter from the compute instance.
     *
     * @param {string} name - The name of the parameter to delete.
     */
    deleteParameter(name: string): void;
    /**
     * Apply the parameters to the scope.
     *
     * @ignore
     */
    applyParameters(): void;
    /**
     * Prepare the compute work dispatch.
     *
     * @param {number} x - X dimension of the grid of work-groups to dispatch.
     * @param {number} [y] - Y dimension of the grid of work-groups to dispatch.
     * @param {number} [z] - Z dimension of the grid of work-groups to dispatch.
     */
    setupDispatch(x: number, y?: number, z?: number): void;
    /**
     * Prepare the compute work dispatch to use indirect parameters from a buffer. The dispatch
     * parameters (x, y, z workgroup counts) are read from the buffer at the specified slot index.
     *
     * When using the device's built-in buffer (buffer parameter is null), this method must be
     * called each frame as slots are only valid for the current frame.
     *
     * @param {number} slotIndex - Slot index in the indirect dispatch buffer. When using the
     * device's built-in buffer, obtain this by calling {@link GraphicsDevice#getIndirectDispatchSlot}.
     * @param {StorageBuffer|null} [buffer] - Optional custom storage buffer containing dispatch
     * parameters. If not provided, uses the device's built-in {@link GraphicsDevice#indirectDispatchBuffer}.
     * When providing a custom buffer, the user is responsible for its lifetime and contents.
     * @example
     * // Reserve a slot in the indirect dispatch buffer
     * const slot = device.getIndirectDispatchSlot();
     *
     * // First compute shader writes dispatch parameters to the buffer
     * prepareCompute.setParameter('indirectBuffer', device.indirectDispatchBuffer);
     * prepareCompute.setParameter('slot', slot);
     * prepareCompute.setupDispatch(1, 1, 1);
     * device.computeDispatch([prepareCompute]);
     *
     * // Second compute shader uses indirect dispatch
     * processCompute.setupIndirectDispatch(slot);
     * device.computeDispatch([processCompute]);
     */
    setupIndirectDispatch(slotIndex: number, buffer?: StorageBuffer | null): void;
}
import type { Shader } from './shader.js';
/**
 * @import { GraphicsDevice } from './graphics-device.js'
 * @import { IndexBuffer } from './index-buffer.js'
 * @import { ScopeId } from './scope-id.js'
 * @import { Shader } from './shader.js'
 * @import { StorageBuffer } from './storage-buffer.js'
 * @import { Texture } from './texture.js'
 * @import { TextureView } from './texture-view.js'
 * @import { VertexBuffer } from './vertex-buffer.js'
 */
/**
 * A helper class storing a parameter value as well as its scope ID.
 *
 * @ignore
 */
declare class ComputeParameter {
    value: any;
    /** @type {ScopeId} */
    scopeId: ScopeId;
}
import type { StorageBuffer } from './storage-buffer.js';
import type { GraphicsDevice } from './graphics-device.js';
import type { Texture } from './texture.js';
import type { VertexBuffer } from './vertex-buffer.js';
import type { IndexBuffer } from './index-buffer.js';
import type { TextureView } from './texture-view.js';
import type { ScopeId } from './scope-id.js';
export {};
